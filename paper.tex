\documentclass{article}
\usepackage[letterpaper,top=2cm,bottom=2.5cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[round]{natbib}
\usepackage{amsmath,amssymb,amsfonts}%
\usepackage{geometry}%
\usepackage{color}
\usepackage{graphicx}
\usepackage{authblk}
\usepackage{nameref}
\usepackage[right]{lineno}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{math,calc,positioning}
\usepackage{url}
\usepackage[symbol]{footmisc}
% JK: turning this off for the moment as I keep clicking through on links
% to the bibliography while reading the text and it's intensely annoying.
% Can reinstate when we're ready to preprint
% \usepackage[hidelinks]{hyperref}

\newcommand{\noderef}[1]{\textsf{#1}}
\newcommand{\tsinfer}[0]{\texttt{tsinfer}}
\newcommand{\kwarg}[0]{\texttt{KwARG}}
\newcommand{\argweaver}[0]{\texttt{ARGweaver}}
\newcommand{\relate}[0]{\texttt{Relate}}
\newcommand{\espalier}[0]{\texttt{Espalier}}
\newcommand{\arbores}[0]{\texttt{Arbores}}

\begin{document}


\title{\vspace{-1.5em} \bf
A general and efficient representation of ancestral recombination graphs}

\author[1]{Yan~Wong}
\author[2,3$\star$]{Anastasia~Ignatieva}
\author[4,5$\star$]{Jere~Koskela}
\author[6]{Gregor~Gorjanc}
\author[7,8]{Anthony~W.~Wohns}
\author[1$\dagger$]{Jerome~Kelleher}
\affil[ ]{\mbox{}\vspace{-2.5em}}

\maketitle

\setlength{\skip\footins}{1em}
\setlength{\footnotemargin}{0.5em}
\renewcommand{\thefootnote}{\arabic{footnote}}
\footnotetext[1]{Big Data Institute, Li Ka Shing Centre for Health
Information and Discovery, University of Oxford, UK}
\footnotetext[2]{School of Mathematics and Statistics, University of Glasgow, UK}
\footnotetext[3]{Department of Statistics, University of Oxford, UK}
\footnotetext[4]{School of Mathematics, Statistics and Physics, Newcastle University, UK}
\footnotetext[5]{Department of Statistics, University of Warwick, UK}
\footnotetext[6]{The Roslin Institute and Royal (Dick) School of Veterinary Studies, University of Edinburgh, UK}
\footnotetext[7]{Broad Institute of MIT and Harvard, Cambridge, USA}
\footnotetext[8]{Department of Genetics, Stanford University School of Medicine, Stanford, USA}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\footnotetext[1]{Joint second author, listed alphabetically}
\footnotetext[2]{Correspondence: jerome.kelleher@bdi.ox.ac.uk}

\vspace{-1em}

\begin{abstract}
New developments have made it possible to infer genetic genealogies in
the presence of recombination at scale, enabling many
downstream applications in population and statistical genetics.
The structure representing such recombinant genetic ancestry
is usually referred to as an ancestral recombination graph (ARG),
% FIXME this sentance needs to change. We want to capture more of the
% idea of the formalisms falling behind actual practise and the
% confusion this is causing
although there is some confusion about the interpretation and little
agreement on specific details.
We propose a concrete definition of ARGs
in terms of genomes and their intervals of genetic inheritance (gARG)
and contrast this with the classical event-based definition (eARG).
We show that eARGs are limited in the patterns
of genetic inheritance that can be represented,
and require a precise description of the details of all recombination events.
We show, in contrast, that the gARG definition
can fully capture the richness of modern large-scale datasets,
enables fine-grained
levels of precision about recombination to be represented,
and forms the basis of an efficient computational framework.
\end{abstract}

\textbf{Keywords:} Ancestral recombination graphs

\linenumbers
\section{Introduction}
\label{sec-intro}
% Para 1: ARGs are cool!
Estimating the genetic genealogy of a set of genome sequences
under the influence of recombination,
usually known as an Ancestral Recombination Graph (ARG), is a long-standing
goal in genetics.
Broadly speaking, an ARG describes the different paths of genetic inheritance
caused by recombination, and encodes a sequence of correlated genealogical
trees along the genome.
Recent breakthroughs
in large-scale inference
methods~\citep{rasmussen2014genome,kelleher2019inferring,speidel2019method,
schaefer2021ancestral,wohns2022unified,zhang2023biobank,zhan2023towards}
have raised the realistic prospect of ARG-based analysis becoming a standard part
of the population and statistical genetics toolkit~\citep{hejase2020summary}.
Applications using inferred ARGs as input have begun to
appear~\citep{osmond2021estimating,
fan2022genealogical,
hejase2022deep,
guo2022recombination,
zhang2023biobank,
nowbandegani2023extremely,
ignatieva2023distribution,
fan2023likelihood}
and many more are sure to
follow~\citep{harris2019database,harris2023using}.
\citet{lewanski2023era} provide a biologically oriented introduction to ARGs
and further discuss their potential impacts.

% Para 2: What are they, though?
Although it is widely accepted that ARGs are important, there is some
confusion about what, precisely, an ARG \emph{is}.
% The grammar is a nightmare here - the stochastic process is singular, right?
In its original form, the ARG is an alternative
formulation of the coalescent with recombination~\citep{hudson1983properties},
where the stochastic process of coalescence and recombination
among ancestral lineages is formalised as a
graph~\citep{griffiths1991two,ethier1990two,griffiths1996ancestral,griffiths1997ancestral}.
Subsequently, ARGs have come to be thought of as a data
structure~\citep{minichiello2006mapping}, i.e.\ describing
a \emph{realisation} of such a random process or an
inference from a sample of genome sequences.
The distinction between stochastic process
and data structure is not clear cut, however,
and subfields use the term
differently (see Appendix~\ref{sec-arg-history}).
% pedantically, ARG is not really a "word"
The term ``ARG'' is now frequently used in a general
sense~\citep[e.g.][]{mathieson2020ancestry,hejase2020summary,
schaefer2021ancestral,harris2023using,zhang2023biobank,fan2023likelihood},
as a data structure
encompassing the varied outputs from modern simulation and
inference methods~\citep{rasmussen2014genome, palamara2016argon, haller2018tree,
kelleher2019inferring, speidel2019method, baumdicker2021efficient, zhang2023biobank}.
This broad usage is a useful generalisation,
but is not, however, compatible with the available formal definitions
derived from the original Griffiths approach.
This mismatch between usage and definition has led to significant
problems, which if not addressed
may impede progress in applying ARGs to understand the biological world.

% % Para 3: what is the problem?
The classical formal definition of an ARG is derived from the
stochastic process, and expressed in terms of events:
the coalescence and recombination events
that occur in the history of a sample. We show that this approach
to representing ARGs (which we refer to as the ``event ARG'', or eARG
encoding) is inherently limiting, insufficient to represent
the complexities of modern datasets, and incompatible with
the outputs of modern large-scale simulation and inference
methods~\citep{kelleher2016efficient,speidel2019method,
kelleher2019inferring,zhang2023biobank}.
We address these problems by providing a more flexible formulation
of an ARG data structure, which we refer to as the ``genome ARG''
or gARG encoding. We show that it is fully compatible with the
classical eARG approach, while providing much more flexibility
in the types of genetic inheritance structures that can be encompassed,
including the outputs of modern methods.
In particular we show that, in contrast with the eARG encoding which
requires precise estimates of each recombination event,
the gARG encoding allows us to systematically describe uncertainty
the temporal ordering of multiple recombinations.

% This is nice to have, but probably won't work in the final version
% without section numbers. Let's deal with that when we get there I guess.
We begin in Section~\ref{sec-gARG} by providing a precise formal definition
of a gARG, illustrated by an example ARG embedded in pedigree.
We then provide a similar definition of the classical eARG
approach in Section~\ref{sec-eARG}, and consider its limitations
in the context of current datasets and research questions.
We then discuss the import concept of ``ancestral material''
in Section~\ref{sec-ancestral-material}, and how this relates
to the process of converting an eARG to a gARG.
Using this new definition for the remainder of the paper,
we continue
in Section~\ref{sec-ARG-and-local-trees} by considering the relationship
between an ARG and its local trees. Contrary to the
prevailing view, we show that a (suitably encoded) sequence of local trees contains
precisely as much information as the corresponding ARG.
The gARG encoding opens a rich new set of details about ARGs,
including the ideas of locally unary nodes
(Section~\ref{sec-locally-unary-edges}),
the levels of detail that can be represented in an ARG
(Section~\ref{sec-ARG-simplification}),
and (relatedly) the degrees of precision about recombination
that can be stored (Section~\ref{sec-precision}).
These ideas have important practical considerations,
which we illustrate by examining the qualitative properties of
ARGs inferred by four recent methods for a classical benchmark
dataset in Section~\ref{sec-example-inferred-args}.
We then discuss how the gARG framework can be
efficiently implementated in Section~\ref{sec-efficiency},
and finish with an assessment of the key challenges facing
the field in the Discussion.
Finally, the literature on ARGs is large and
confusing, and we attempty to clarify some important aspects
in appendices, including
a brief history of ancestral graphs (Appendix~\ref{sec-arg-history}),
a description of the Big and Little ARG stochastic processes
 (Appendix~\ref{sec-big-and-little-arg}),
a survey of ARG inference methods (Appendix~\ref{sec-survey-arg-infer}),
and a discussion of ARGs at an individual vs cell
lineage level (Appendix~\ref{sec-cell-lineages-and-args}).

\section{Genome ARGs}
\label{sec-gARG}
We define a genome as the complete set of genetic material that a child
inherits from one parent. A diploid individual  
% Q: will someone nitpick that we're assuming diploid obligate sexual species?
therefore carries two genomes, one inherited from each parent (we assume diploids here
for clarity, but the definitions apply to organisms of arbitrary ploidy).
We will also use the term ``genome'' in its
more common sense of ``the genome'' of a species,
and hope that the distinction will be clear from the context.
We are not concerned here with mutational processes or observed sequences,
but consider only processes of inheritance,
following the standard practice in coalescent theory.
We also do not consider structural variation, and assume that all
samples and ancestors share the same genome coordinate space.

A genome ARG (gARG) is a directed acyclic graph in which nodes represent
haploid genomes and edges represent
genetic inheritance between an ancestor and a descendant.
The topology of a gARG specifies that genetic inheritance
occurred between particular
ancestors and descendants, but the graph connectivity
does not tell us which \emph{parts} of their genomes were inherited.
In order to capture the effects of recombination
(and other processes that lead to partial genome inheritance)
 we ``annotate'' the edges with the genome
coordinates over which inheritance occurred.
This is sufficient to capture the effects of any form of
genetic inheritance (excluding structural variation).

We can define a gARG formally as follows.
Let $N = \{1, \dots, n\}$ be the set of nodes representing
the genomes in the gARG,
and  $S \subseteq N$ be the set of sampled genomes.
Then, $E$ is the set of edges, where each element
is a tuple $(c, p, I)$ such that $c, p \in N$ are the child and
parent nodes and $I$ is the set of disjoint genomic intervals
over which genome $c$ inherits from $p$.
Thus, each topological connection between
a parent and child node in the graph is annotated with a set of
inheritance intervals $I$.
Here, the terms parent and child are used in the graph sense;
these nodes respectively represent ancestor and descendant genomes,
which can be separated by multiple generations.
We will use these two sets of terms interchangeably.

In many settings, nodes are dated, i.e.\ each
node $u\in N$ is associated with a time $\tau_u$.
However, the topological ordering
defined by the directed graph structure
 is sufficient for many applications
thus we do not require node dates to be known.
% This should be obvious, but seems like it needs to be said
In practical settings, we will wish to associate additional
metadata with nodes such as sample identifiers or quality-control metrics.
It is therefore best to think of the
integers used here in the definition of a node as an \emph{identifier},
with which arbitrary additional information can be associated.
% Note: I don't see why we have to apologise for defining nodes as
% integers, that's just the definition. I don't think anyone really
% has a problem with this.
% Concretely defining nodes as integers in this way has some
% significant advantages. In particular, it provides a direct link
% between an ARG and its local trees in terms of a well-defined
% combinatorial object (Section~\ref{sec-ARG-and-local-trees}),
% as well as enabling straightforward connection between
% definitions and practical implementation (Section~\ref{sec-efficiency}).

\begin{figure}
\begin{center}
    \includegraphics[width=\textwidth]{illustrations/arg-in-pedigree}
\end{center}
\caption{\label{fig-arg-in-pedigree}
% TODO caption needs another pass. Once the full section has been written
% it'll be clearer what we need to say in the caption vs the text.
An example genome ARG (gARG) embedded in a pedigree.
(A) Diploid individuals (blue), visualised in a highly inbred pedigree and
labelled $D_1$ to $D_8$,
contain both paternal and maternal  genomes
labelled \noderef{a} to \noderef{p}. Black lines show inheritance paths connecting
genomes in the current generation (\noderef{a} to \noderef{d}) with their ancestors.
Genomes \noderef{a} and \noderef{c} are the product of two independent
recombination events (red) between
the paternal genomes \noderef{e}
and \noderef{f}, and regions of genome inherited are shown with shaded colour.
Genomes are shaded such that where, backwards in time,
they merge into a common ancestor, the merged region is darker.
(B) The corresponding gARG along with inheritance annotations on all edges
(partial inheritance in bold).
(C) The corresponding local trees.
}
\end{figure}

As illustrated in Fig.~\ref{fig-arg-in-pedigree},
the gARG for a given set of individuals is embedded in their pedigree.
The figure shows the pedigree of eight diploid individuals, along with paths
of genetic inheritance and constituent genomes.
Here, and throughout,
nodes are labelled with lowercase alphabetical letters
rather than integer identifiers, to avoid confusion with genomic intervals.
Thus individual $D_1$ is composed
of genomes \noderef{a} and \noderef{b}, which are inherited from its
two parents $D_3$ and $D_4$. Each inherited genome may be the recombined product
of the two genomes belonging to an individual parent.
In this example,
genome \noderef{b} was inherited directly from $D_4$'s genome \noderef{g} without
recombination, whereas
genome \noderef{a} is the recombinant product of
$D_2$'s genomes \noderef{e} and \noderef{f} crossing over at position 2.
Specifically, genome \noderef{a} inherited the (half-closed)
interval $[0, 2)$ from genome \noderef{e} and $[2, 10)$ from genome \noderef{f}.
These intervals are shown attached to the corresponding graph edges.
The figure shows the annotated pedigree with realised inheritance of genomes
between generations (A), the corresponding gARG (B), and finally the corresponding
sequence of local trees along the
genome (C).
% Jerome: this feels unecessary and "genealogy" is often interpreted as
% "pedigree" so needs to be used very carefully.
% The local trees represent the genealogy of genomes \noderef{a}--\noderef{d},
% which changes between local trees due to recombination.
The local trees span the three genome regions delineated
by the two recombination breakpoints that gave rise to these genomes;
further discussion on
how local trees are embedded in an ARG is provided in Section~\ref{sec-ARG-and-local-trees}
% Following the above definitions, corresponding data encoding for
% this gARG is shown in Tab.~\ref{tab-gARG-data}.

% % I feel like sophisticated readers would at this point be saying,
% % ah, yeah, that's basically what an ARG is just in different words;
% % what's the point of this paper?
The genome ARG framework defined here is
in many ways simply a clarification of existing treatments
\cite[e.g.][]{mathieson2020ancestry,shipilina2023origin},
adding concrete details to describe the
differential inheritance of genetic material between genomes.
% This is definitely needed for the Nicks, who are always thinking
% about the deeper processes and are quite happy being loosey-goosey
% with representation details
It is important to note that here, and throughout,
we are not questioning the form of the
actual ancestral processes that occur in nature, but rather how we
\emph{represent} the outcomes of such processes in a practical manner.
% Again, need to remind the reader that there's an actual point
% to all this getting stuck into the details.
These practical details,
as demonstrated in later sections, have important
consequences not only for how methods exchange information about
simulated and inferred ARGs, but more fundamentally in
how we set our goals for inference and evaluate the success of results.

\section{Event ARGs}
\label{sec-eARG}
% Trying to be totally, boringly, abundantly, blatantly clear here what we're
% talking about.
In this section we define the classical view of an ARG data structure,
and illustrate its limitations. We are
interested in the details of how ARGs are described mathematically,
and as a consequence, how they are represented in a practical sense
as the output of inference programs.
Where such concrete details of an ARG data structure
(the encoding) are
% TODO more?
mathematically defined~\citep[e.g.][]{
rasmussen2014genome,gusfield2014recombinatorics,ignatieva2021kwarg}
they follow the approach described by Griffiths and colleagues
(but see~\citet{parida2011minimal} and \citet{zhang2023biobank}
for notable exceptions), and the majority of
% Note the "an" here to avoid cases like ARGweaver
ARG inference methods use it as an output format
\citep[(TODO exhaustive list)][]{rasmussen2014genome,ignatieva2021kwarg}.
In this Griffiths encoding, we have two different types of node in the graph,
representing the common ancestor and recombination events
in the history of a sample.
At common ancestor nodes, the inbound lineages merge into a
single ancestral lineage with one parent, and at recombination
nodes a single lineage is split into two independent
ancestral lineages. Recombination nodes are annotated with
the corresponding crossover breakpoints. These breakpoints
are used to construct the local trees.
This is done by tracing rootwards through the graph from the samples,
making decisions about which outbound edge to follow through
recombination nodes based on the breakpoint
position~\citep{griffiths1996ancestral}.
Because it is focused on recording events and their properties,
we will refer to this Griffiths encoding as the ``event ARG'', or eARG
encoding. Fig.~\ref{fig-event-arg} shows an example of a classical
eARG with three sample genomes (\noderef{a}, \noderef{b}, and \noderef{c})
and a single recombination event (node \noderef{d}) with a breakpoint
at position $x$.
We assume here that \noderef{d} inherits genetic material to the
left of $x$ from \noderef{e} and to the right of $x$ from \noderef{f}.

\begin{figure}
\centering
\tikzmath{\x1 =0; \x2=8;\xx=12.5; \x3=14; \xt=18;}
\begin{tikzpicture}[x=5mm, y=5mm, node distance=2mm and 20mm]
\tikzset{greynode/.style={circle,fill,inner sep=1},
nodelabel/.style={font=\footnotesize}}


\node [anchor=north west] at (\x1,6) {A};
\node [anchor=north west] at (\x2,6) {B};
% \node [anchor=north west] at (\xt,6) {C};

%%% (A) ARG

\node (s0) [greynode] at (\x1 + 0, 0) {};
\node (s1) [greynode] at (\x1 + 3, 0) {};
\node (s2) [greynode] at (\x1 + 6, 0) {};
\node (s3) [greynode] at (\x1 + 3, 1) {};
\node (s4) [greynode] at (\x1 + 1, 2) {};
\node (s5) [greynode] at (\x1 + 5, 3) {};
\node (s6) [greynode] at (\x1 + 3, 4) {};

\draw (s1) -- (s3);
\draw (s0) |- (s4);
\draw (s4) -- (\x1 + 2,2) |- (s3);
\draw (s4) |- (s6);
\draw (s3) -- (\x1 + 4,1) |- (s5);
\draw (s2) |- (s5);
\draw (s5) |- (s6);

%%% (B) Trees
\node (l0) [greynode] at (\x2 + 0, 0) {};
\node (l1) [greynode] at (\x2 + 2, 0) {};
\node (l2) [greynode] at (\x2 + 3, 0) {};
\node (l3) [greynode] at (\x2 + 1, 2) {};
\node (l4) [greynode] at (\x2 + 2, 4) {};

\draw (l0) |- (l3);
\draw (l1) |- (l3);
\draw (l2) |- (l4);
\draw (l3) |- (l4);

\node (r0) [greynode] at (\x3 + 0, 0) {};
\node (r1) [greynode] at (\x3 + 1, 0) {};
\node (r2) [greynode] at (\x3 + 3, 0) {};
\node (r3) [greynode] at (\x3 + 2, 3) {};
\node (r4) [greynode] at (\x3 + 1, 4) {};

\draw (r0) |- (r4);
\draw (r1) |- (r3);
\draw (r2) |- (r3);
\draw (r3) |- (r4);

\foreach \u/\lab in {
        s0/$\noderef{a}$, s1/$\noderef{b}$, s2/$\noderef{c}$,
        r0/$\noderef{a}$, r1/$\noderef{b}$, r2/$\noderef{c}$,
        l0/$\noderef{a}$, l1/$\noderef{b}$, l2/$\noderef{c}$}
    \node[nodelabel,anchor=south] at ([yshift=-12pt]\u) {\lab};

\foreach \u/\lab in {
        s6/$\noderef{g}$,
        l4/$\noderef{g}$,
        r4/$\noderef{g}$}
    \node[nodelabel,anchor=south] at (\u) {\lab};

\node [nodelabel,anchor=north west] at ($(s3) + (\x1 + 0,0)$) {$x$};
\foreach \u/\lab in {
        s4/$\noderef{e}$,
        l3/$\noderef{e}$}
    \node[nodelabel,anchor=south west] at (\u) {\lab};
\foreach \u/\lab in {
        s5/$\noderef{f}$,
        r3/$\noderef{f}$}
    \node[nodelabel,anchor=south east] at (\u) {\lab};
\foreach \u/\lab in {s3/$\noderef{d}$, s6/$\noderef{g}$}
    \node[nodelabel,anchor=south] at (\u) {\lab};

\draw[dashed] (\xx,0) -- (\xx, 4);
\node[nodelabel,anchor=north] at (\xx,0) {$x$};


% %%% (C) Encoding
% \node [nodelabel,anchor=north west] at ($(\xt,5)$) {
% \begin{tabular}{c|c|l}
% % \multicolumn{2}{c}{Breakpoints}\\
% Node & Breakpoint & Parents\\
% \hline
% $\noderef{a}$ & $\varnothing$ & [\noderef{e}]\\
% $\noderef{b}$ & $\varnothing$ & [\noderef{d}] \\
% $\noderef{c}$ & $\varnothing$ & [\noderef{f}]\\
% $\noderef{d}$ & $x$ & [\noderef{e}, \noderef{f}] \\
% $\noderef{e}$ & $\varnothing$ & [\noderef{g}]\\
% $\noderef{f}$ & $\varnothing$ & [\noderef{g}]\\
% $\noderef{g}$ & $\varnothing$ & []\\
% \end{tabular}};

\end{tikzpicture}
\caption{\label{fig-event-arg}
A classical event ARG. (A) Standard graph depiction with
breakpoint $x$ associated with the recombination node \noderef{d}.
Nodes \noderef{e}, \noderef{f} and \noderef{g} are common ancestor events.
(B) Corresponding local trees to the left and right of breakpoint $x$
(note these are shown in the conventional form in which only coalescences
within the local tree are included; see Section~\ref{sec-ARG-and-local-trees}
% TODO: check above if we want to refer to sec-ARG-and-local-trees or some other!
for a discussion of this important point).
}
\end{figure}

% eARGs are representationally for limited interchange
While the Griffiths approach of annotating recombination nodes with a
breakpoint in an eARG is a concise and elegant way of describing realisations
of the coalescent, it has some significant issues when applied to the
complexities of present-day datasets. The eARG encoding explicitly models only
two different types of event and thus anything that is not a single crossover
recombination or common ancestor event, must be incorporated
either in a roundabout way using these
events, or by adding new types of event to the encoding. For example, gene
conversion could be accommodated either by stipulating a third type of event
(annotated by two breakpoints and corresponding traversal conventions for
recovering the local trees) or by two recombination nodes joined by a
zero-length edge. From the perspective of practical interchange of data between
inference methods and downstream applications, both
workarounds are problematic, and the gARG encoding described in the previous
section offers a much simpler solution.
Modern datasets contain many more complexities which the eARG encoding
is ill-suited to represent (see Discussion).

There is also a certain clarity gained by explicitly modelling nodes
in the inheritance graph as genomes.
Outside of the context of a
% The point being, events are perfectly well defined in the models
% but not in reality
mathematical model, an ``event'' is a slippery concept.
For example, \emph{which} genome along a chain of cell divisions should be
regarded as the one where an event occurred
(Appendix~\ref{sec-cell-lineages-and-args}),
or whether multiple recombinations
within a single individual should be regarded as one or multiple events are
debatable.
% If we want to have an ARG software ecosystem then such fireside
% discussions won't help.
From the perspective of a concrete data structure,
ideally forming the basis of an ecosystem of interoperable
inference and analysis methods, such debates
are unproductive.

\section{Ancestral material and sample resolution}
\label{sec-ancestral-material}
Ancestral material~\citep{wiuf1999ancestry,wiuf1999recombination}
is a key concept in understanding the overall inheritance structure
of an ARG. It denotes the genomic intervals ancestral to a set of samples
on the edges of an ARG.
In Fig.~\ref{fig-arg-in-pedigree}, for example, we have
four sample genomes, \noderef{a}--\noderef{d}. As we
trace their genetic ancestry into the previous generation
(\noderef{e}--\noderef{h}), we can think of the ancestral
material of the samples propagating through the graph
backwards in time. In the interval $[2, 7)$, there is a
local coalescence where nodes \noderef{a} and \noderef{c}
find a common ancestor in \noderef{f}. Thus, in this interval,
the total number of genome segments that are ancestral to the
sample is reduced from four to three. Note that in the same
interval, node \noderef{e} is not ancestral to any
of the samples: it carries non ancestral material.
This process of local coalescence continues through the
graph, until all samples reach their most recent common
ancestor in node \noderef{n}.

The process of tracking local coalescences and updating
segments of ancestral material is a core element of
Hudson's seminal simulation
algorithm~\citep{hudson1983testing,kelleher2016efficient},
and the key distinguishing feature between the
``Big'' and ``Little'' ARG stochastic processes
(see Appendix~\ref{sec-big-and-little-arg}).
The ability to \emph{store} the resolved ancestral material
for a sample
in an ARG is also a key distinction between the eARG and gARG
encodings. Because an eARG stores only the graph topology and
recombination breakpoints, there is no way to locally
ascertain the ancestral material without traversing the graph
rootwards from the samples,
resolving the effects of recombination and common ancestor events.

Efficiently propagating and resolving ancestral material for
a sample through a pre-existing graph is a well-studied problem,
and central to recent advances in individual-based forwards-time
simulations~\citep{kelleher2018efficient,haller2018tree}.
In contrast to the usual ``retrospective'' view of ARGs
discussed so far, these methods record an ARG forwards in
time in a ``prospective'' manner. Genetic inheritance relationships
are recorded exhaustively, generation-by-generation,
leading to a rapid build-up of information, much of which
will not be relevant to the genetic ancestry of the current population.
This redundancy is periodically removed using the ``simplify''
algorithm~\citep{kelleher2018efficient}, which propagates and
resolves ancestral material.
Simplification allows efficient subsetting of ARGs (removing both samples and
certain levels of detail about recombination, as discussed in
Section~\ref{sec-ARG-simplification}), and is also the key enabling factor when
incorporating propective ARGs into
forward-time simulation.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{illustrations/ancestry-resolution}
\caption{\label{fig-ancestry-resolution}
Converting the \citet[][Fig.~1]{wiuf1999recombination} example
to a sample-resolved gARG. (A) The original eARG; square nodes represent events, with
each recombination (red) containing a breakpoint.
(B) The corresponding gARG with breakpoints directly converted to
edges annotated with inheritance intervals.
(C) The sample-resolved gARG resulting from simplifying with respect
to the sample genomes, \noderef{a}, \noderef{b}, and \noderef{c}.
Dashed lines show edges that are
no longer present (in practice, nodes \noderef{g}, \noderef{j}, and \noderef{q} would also be removed).
Coalescence with respect to the sample is indicated by shaded bars, as
in Fig~\ref{fig-arg-in-pedigree}A; nodes \noderef{n}, \noderef{o}, \noderef{p}, \noderef{q} have incomplete
bars showing that local ancestry of entirely coalesced regions is omitted.
Line thickness is proportional to the genomic span of each edge.
Nodes representing recombination events are retained
for clarity, but could be removed by simplification if
desired.
}
\end{figure}

Any eARG can be converted to a sample-resolved gARG using the same machinery,
and the two-step process is illustrated in Fig.~\ref{fig-ancestry-resolution}.
The first step is to take the input eARG (Fig.~\ref{fig-ancestry-resolution}A),
duplicate its graph topology, and then add inheritance annotations
to each of the gARG's edges (Fig.~\ref{fig-ancestry-resolution}B) as follows.
If a given node is a common ancestor event, we annotate the single
outbound edge with the interval $[0,L)$, for a genome of length $L$. If the
node is a recombination event with a breakpoint $x$, we annotate the two
outbound edges respectively with the intervals $[0, x)$ and $[x, L)$. These
inheritance interval annotations are clearly in one-to-one correspondence with
the information in the input eARG. They are also analogous to the
inheritance intervals we get on the edges in a prospective gARG
produced by a forwards-time simulation, which are concerned with recording
the local genetic relationship between a parent and child genome and not
necessarily minimal in terms of the resolved ancestral material of a sample.
Thus, the final step is to use the ``simplify'' algorithm to perform this
resolution and produce the sample-resolved
gARG (Fig.~\ref{fig-ancestry-resolution}C).

The sample-resolved gARG of Fig.~\ref{fig-ancestry-resolution}C
differs in some important ways to the
original eARG (Fig.~\ref{fig-ancestry-resolution}A).
Firstly, we can see that some nodes and edges have been removed entirely
from the graph.
The ``grand MRCA'' \noderef{q} is omitted from the
sample-resolved gARG because all segments of the genome have
fully coalesced before it is reached. Likewise, the edge
between \noderef{g} and \noderef{j} is omitted because the recombination
event at position $5$ (represented by node \noderef{g})
fell in non-ancestral material.
More generally, we can see that the sample resolved
gARG of Fig.~\ref{fig-ancestry-resolution}C
allows for ``local'' inspection
of an ARG in a way that is not possible in an eARG.
Because the ancestral material is stored with each edge, the
cumulative effects of events over time can be reasoned
about, without first ``replaying'' those events.
Many computations
that we wish to perform on an ARG will require resolving
the ancestral material with respect to a sample.
% this is weak, but would be good to emphasise this point.
% you just end up running simplify lots of times, in your
% downstream algs
The gARG encoding
allows us to perform this once
and to store the result,
whereas the eARG encoding requires us to repeat the process
each time.

Note that the \citet{wiuf1999recombination} eARG
in Fig.~\ref{fig-ancestry-resolution} is not particularly
representative, because inference or simulation methods will usually
only generate ARGs containing nodes and edges ancestral to the sample
(see the discussion of the ``Big ARG'' stochastic process in
Appendix~\ref{sec-big-and-little-arg}, however).
Nonetheless, it is an instructive example from the literature which highlights several
important properties of ARGs, and the general point about
the need to resolve ancestral material ``on the fly'' for eARG traversals
holds.

% \section{Retrospective vs prospective ARGs}
% \label{sec-retro-pro}
% The ARG concept arose from a \emph{retrospective} view of inheritance.
% For example the definition of an eARG, as discussed above, is invariably
% couched in terms of the events that occured in the history of some set of sampled
% genomes. Similarly, the genome ARG in Fig.~\ref{fig-arg-in-pedigree}
% is retrospective because it only includes information
% about genetic inheritance relative to the sample individuals
% $D_1$ and $D_2$ (genomes \noderef{a}--\noderef{d}).
% That is, only the inheritance
% history of the sample genomes \noderef{a}--\noderef{d} is recorded in the ARG.
% % Gregor & Jerome think that "inheritance" is clearer here than "transmission"
% Genetic inheritance must have occurred between (e.g.)
% $D_8$ and her daughter $D_6$, but this is not recorded because
% it is not relevant to the genetic ancestry of the sample genomes.

% There is no particular reason, however, that ARGs must be
% retrospective. Recent advances in individual-based forward-time simulation
% ~\citep{kelleher2018efficient,haller2018tree} depend upon the ability to
% record gARGs in a \emph{prospective} manner.
% In a prospective gARG, the inheritance intervals $I$
% on an edge joining ancestor genome $v$ and descendant $u$
% define \emph{all} regions of genome that $u$ inherited from $v$.
% Thus, these inheritance intervals are
% concerned only with the genetic relationship
% between the nodes in question, and are not defined with respect
% to any given set of samples. They simply record the immediate
% genetic inheritance between two genomes
% (in the simplest case, between a parent and a child).
% \citet{kelleher2018efficient} refer to the structure
% recording all such forwards-in-time genetic relationships
% as an ``embellished pedigree`` (and suggest the term ``nedigree'' as a shorthand).
% Describing this instead as a ``prospective ARG'', emphasising
% the use of the same data structures and the direct connection with
% the usual retrospective interpretation of an ARG, may be
% more useful.

% The exhaustive recording of full inheritance intervals from generation
% to generation leads to a rapid build-up of information, much of which
% may not be relevant to the genetic ancestry of the current population.
% This redundancy can be periodically removed using the ``simplify'' algorithm,
% described in detail by \citet{kelleher2018efficient}. Simplification
% allows efficient subsetting of ARGs (removing both samples and certain
% levels of detail about recombination, as discussed in Section~\ref{sec-ARG-simplification}),
% and is also the key enabling factor when incorporating propective ARGs into
% forward-time simulation.
% The core algorithm involves the concept of
% ``ancestral material''~\citep{wiuf1999ancestry,wiuf1999recombination}:
% the genomic intervals ancestral to a set of samples,
% scattered across lineages (the edges of the graph)
% at some time in the past. In the next section, we outline how
% tracing ancestral material allows the identification and removal of nodes
% and inheritance intervals, such that
% only genetic ancestry relevant to the current population is retained.

\section{ARGs and local trees}
\label{sec-ARG-and-local-trees}
% (We use ``local'' rather than
% ``marginal''
% % could list loads here, but not much point.
% trees~\citep[e.g.][]{griffiths1996ancestral,minichiello2006mapping,kelleher2016efficient}
% to avoid the potential confusion with the
% statistical concept of marginal distributions.)
The relationship between an ARG and its corresponding
local trees is subtle and important.
A fundamental property of genetics is that a
given DNA nucleotide is inherited from exactly one parent genome,
both at an organismal and cell-by-cell level
(Appendix~\ref{sec-cell-lineages-and-args}).
These chains of single-parent inheritance over time give rise,
by definition, to a tree structure.
As a result of recombination, adjacent nucleotides can have
different chains of inheritance, and
an ARG encodes the entire ensemble of local trees along the
% Said "sample of genomes" originally, but using term "genome" in two
% different ways in the same sentence then.
genome for a given sample.
% This is for Yan - to me this is a given, but maybe some people feel
% the following is overly formal?
Precisely defining the process by which local trees are extracted
from an ARG is essential to our understanding of how they
are related, and we require a concrete mathematical structure
to describe the local trees.

Oriented trees provide a
convenient formalism to capture these parent-child relationships
in a well-defined combinatorial object.
% There's no need for a comma
Let $\pi_1\dots\pi_n$ be a sequence of integers, such that $\pi_u$
denotes the parent of node $u$, and $\pi_u = 0$ if $u$ is a
root~\cite[p.\ 461]{knuth11combinatorial}.
This encoding is particularly useful to describe
evolutionary trees because parent-child relationships are
important but the ordering of children at a node is
not~\citep{kelleher2013coalescent,kelleher2014coalescent,
kelleher2016efficient}.
Thus, for a given gARG with nodes $\{1, \dots, n\}$ and
edges $E$ (Section~\ref{sec-gARG}), we recover the local tree
at position $x$ as follows.
We begin by setting $\pi_u = 0$ for each $1 \leq u \leq n$.
Then, for each sample node in $S$ we trace its path rootwards through the
ARG for position $x$, and record this path in $\pi$.
Specifically, at a given node $u$,
we find an edge $(c, p, I) \in E$ such that $u = c$ and $x \in I$, and set
$\pi_c \leftarrow p$. We then set $u \leftarrow p$, and repeat
until either $\pi_u \neq 0$ (indicating we have traversed this section
of the ARG already on the path from another sample) or there
is no matching outbound edge (indicating we are at a root).
Note that the local trees for an ARG are ``sparse''~\citep{kelleher2016efficient},
because many ancestral nodes will not be reachable from the
samples at a given position (so their corresponding entries in $\pi$ will be zero).

This combinatorial approach provides at least
one novel insight, clarifying the fundamental relationship between
ARGs and local trees.
If we are given the sequence of local trees for a gARG
encoded as an oriented tree along with the genome interval
covered by each tree, then we can recover precisely the same ARG.
% We do this site-by-site for simplicity, but hopefully it's obvious
% that this isn't necessary?
More formally, suppose we are given the local tree $\pi^x_1\dots\pi^x_n$
for each nucleotide position $1 \leq x \leq L$ on a genome of length $L$.
Then, the edges of the ``local ARG'' for this tree is given by
$E^x = \{(u, \pi_u^x, \{x\} \mid \pi_u^x \neq 0\}$. Since the ARG
edges are defined by $(c, p, I)$ tuples, where the set $I$ defines
the positions over which node $c$ inherits from parent $p$, we can
then simply combine the ``local ARGs'' for each position $x$
to recover precisely the same set of edges as the original ARG.
Thus, under this definition, there
is a one-to-one correspondence between an ARG and
the sequence of local trees that it encodes.

This is not the prevailing view, however.
\cite{kuhner2017consensus} argue that the
``interval-tree'' representation of
an ARG (the local trees and the genome intervals they cover)
``does not contain all of the information in the underlying ARG: it lacks the
number of recombinations occuring at each site, the times at which
recombinations occurred, and the specific sequences involved as recombination
partners.''
\cite{shipilina2023origin} discuss the same ideas,
and note that the
``full ARG...~contains more information than the series of tree
sequences along the genome''.
% Could cite some more? E.g. KwARG paper says
% "We note that ARGs contain more information than local trees"
% If even Ana and Jotun are wrong about this it then it must be
% significant! ;)
These statements that an ARG
contains more information than its local trees are only true
if we use a representation of the local trees that discards
information about those local trees that can be derived from the ARG.

There are two properties of how evolutionary trees are conventionally
represented that lead to this
% We can rephrase... suggestions?
disagreement about the relationship between local trees and an ARG.
Firstly, the internal nodes of evolutionary trees are usually
considered to be \emph{unlabelled}, or equivalently, labelled by the leaves which they subtend.
The same canonical labelling cannot be used for internal ARG nodes because the leaves they subtend will typically vary by genomic position. If we do not label the tree nodes in a way which is persistent across the sequence of local trees in the ARG, we lose the fact that
the \emph{same} ancestors sometimes persist across multiple trees.
Defining ARG nodes as integers and using the oriented tree encoding
explicitly labels internal nodes, and makes the relationship between
tree and ARG nodes clear.

The second property of how evolutionary trees
are conventionally represented that is unhelpful in the context of ARGs is their
focus on branching points (coalescences), i.e.\
nodes that have two or more children.
As the introductory paragraph of this section emphasised,
parent-child relationships are what fundamentally define a tree,
and branching points can be seen as incidental. This is reflected
by the oriented tree encoding which simply stores the local
parent-child relationships, and does not, for example,
directly tell us how many children a particular node has.
The local tree at a given position records the \emph{path} through
the ARG, and if we discard sections of that path that are not
branching points in the local tree, we lose information about the ARG.
We return to this important point in the following two sections.

It is important that we make the distinction here between the local
trees that we can derive from a known ARG (as just discussed),
and the ARGs that we can derive from a sequence of \emph{estimated}
local trees.
The ARG inference method
\espalier~\citep{rasmussen2022espalier} is illustrative in this context.
It begins by splitting an input sequence alignment into
segments that are assumed to be non-recombining. Within
each segment, an initial local tree is estimated using
standard phylogenetic methods. By necessity, these local
trees will contain internal nodes that are unlabelled and
consist only of branching points: there is no information
shared between the independent tree estimation steps
across segments. Part of the task of stitching
these trees together
into an ARG is then, essentially, to generate labels for
the internal nodes, and decide which nodes persist
across multiple local trees.
% TODO add a sentence here saying how it does this.
% that's what we're interested in illustrating here.
\espalier\ is specifically interested
in the details of recombination events,
and also attempts to infer
the precise subtree prune-and-regraft (SPR)
operations~\citep{hein1990reconstructing,song2003on,song2006properties}
induced by recombination between these partially reconciled local trees.
A similar problem is tackled by \arbores~\citep{heine2018bridging}, which explores a space of ARGs by fixing a starting ARG, and then repeatedly erasing and resimulating candidate SPR moves connecting two fixed, leaf-labelled local trees.
Exploration is done by varying the positions of these boundary trees along the sequence.
Inferring the SPRs between leaf-labelled trees is
NP-hard~\citep{hein1996complexity,allen2001subtree,bordewich2005computational},
but it is unclear what the complexity is when there
is a degree of internal node sharing between trees.
% I don't really know if this is true, it's just a way of wrapping the
% section up by saying that other things we thought were settled might
% be worth thinking about again.
The combinatorial formulation of ARGs and local trees provided here
may help clarify these fundamental questions.

\section{Locally unary nodes}
\label{sec-locally-unary-edges}
As discussed in the previous section, the local tree at a given position
$x$ is best seen as the path through the ARG at that position, defined
by the oriented tree $\pi^x_1\dots\pi^x_n$. This path does not directly
contain information about branching points, and defining a
node's arity (number of child nodes) is therefore useful.
The ``local arity'' of a node is the number of children it has
in the local tree at position $x$, i.e., $a^x_u = |\{v : \pi^x_v = u\}|$
for each $1 \leq u \leq n$. The ``ARG arity'' of a node $u$ is the
number of children it has in the graph topology, i.e.\
$a_u = |\{v: (v, u, I) \in E\}|$. Thus, the local arity is less than
or equal to the ARG arity (more precisely, $0 \leq a^x_u \leq a_u$),
and the local arity of a node may change as we move along the genome.

This distinction between ARG and local tree arity is mainly
of interest when we consider unary nodes, those that have
a single child.
Returning to the example in Fig~\ref{fig-arg-in-pedigree}, nodes
\noderef{g} and \noderef{h}
are ARG-unary (Fig~\ref{fig-arg-in-pedigree}B), and are consequently
also unary in the local trees (Fig~\ref{fig-arg-in-pedigree}C).
On the other hand, node \noderef{f} has two children
in the graph, but is binary only
in the local tree covering the interval $[2, 7)$,
representing the coalescence of samples \noderef{a} and \noderef{c}
in this genome region. Over the interval $[0, 2)$ no coalescence occurs,
but we still record the fact that genome \noderef{c} inherits from \noderef{f}
in the local tree. Thus, \noderef{f} has a single child in this
interval and it is unary in this local tree: in other words is is a \emph{locally unary} node.
% TODO note that node e is CA but not coalescent, and refer to where we discuss this.
In another example, \noderef{e} is binary in the graph, but is
locally unary in all local trees in which it is present.
This is because \noderef{a} and \noderef{c} are both recombinant
offspring of \noderef{e} and \noderef{f}, and,
in this example,
\noderef{a} inherits from
\noderef{e} over the interval $[0, 2)$,
and \noderef{c} inherits from \noderef{e} over $[7, 10)$.

[FIXME this isn't true, add comment about eARG conversion]
Outside of the context of simulation, ARG-unary nodes are
only likely to occur in longitudinal datasets where genetic
data is sampled at many timepoints and recombination
is rare (e.g.~SARS-CoV-2; see Discussion).
In contrast, locally unary nodes, are a common and important feature
of many different types of ARG.
As discussed in the previous section,
without these nodes marking the passage
of ancestral material through specific ancestors, the local trees
lack information about events other than local coalescence.
% Not sure if switching example will confuse people here, but would
% like to contrast with example where we don't use unary nodes to
% emphasise the point that we lose info
For example, the local trees for the classical event ARG
depicted in Fig.~\ref{fig-event-arg}B follow the usual conventions
and do not include any information about the recombination
that occurred at node \noderef{d}. Given these two local trees
in isolation
% (without further information about the corresponding ARG)
we lack specific information about the recombination.
Explicitly recording that node \noderef{d} lies on the
branch joining \noderef{b} to \noderef{e} in the left hand
tree, and \noderef{b} to \noderef{f} in the right hand tree
resolves all ambiguity, and makes the collection of local
trees exactly equivalent to the corresponding ARG (see previous section).
Unary nodes are a vital link between ARGs and local trees, and we
cannot fully reason about how a local tree is embedded in an ARG
without them. As we see in the next section, both ARG and locally
unary nodes occur in a range of different scenarios.

% NOTE: this para doesn't serve much purpose now I think.

% Nodes with one child are not a standard feature of evolutionary trees
% or the ARG literature
% (although \citet{mathieson2020ancestry} show examples in which the ARGs
% contain unary nodes, and state that paths are
% ``implicitly passing through points representing specific individuals.'').
% We are usually interested in
% nodes that have at least two children because these
% are in principle detectable from mutational differences
% arising in the respective subtrees.
% A tree branch may correspond to many generations
% of individuals (or indeed cell divisions; see Appendix \ref{sec-cell-lineages-and-args})
% and there is usually
% little information about these intermediates, and hence limited utility
% in modelling them.
% As we see in the next section, however, there is a range of
% different ways in which ARG nodes can be locally unary. Furthermore,
% several inference methods infer ARGs containing locally unary nodes
% (see Section~\ref{sec-precision}).

\section{Levels of simplification}
\label{sec-ARG-simplification}
ARG simplification is a powerful tool.
In general, we can think of
simplification as the process
of removing nodes and re-writing edges (and their inheritance annotations)
to remove various types of redundancy.
The redundancy that we are interested in
% We are interested in both graph and local unary, so qualifying this
% would just make it less readable, IMO
revolves around the presence of unary nodes (see previous section).
We illustrate this successive removal of redundancy
through a series of simplification steps
in Fig.~\ref{fig-simplification};
the graph is shown on the left and the corresponding sequence
of local trees on the right.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{illustrations/simplification}
\caption{\label{fig-simplification}
Levels of ARG simplification.
(A) An example ARG simulated from a diploid Wright-Fisher model.
(B) Remove all
singly-connected graph components (e.g., diamonds such as \noderef{jlnm}).
(C) Remove nodes that never represent coalescences,
i.e.\ are unary everywhere (e.g.\ \noderef{n} and \noderef{r}).
(D) Rewrite edges to bypass nodes in local trees in which they are unary.
In each case, the graph is shown on the left
and corresponding local trees on the right.
% Repetition here, but I'm thinking about the casual "I'm just reading
% the captions reader" who might not realise that there's an essential
% ingredient missing from the graph version
In the interest of visual clarity, inheritance intervals are not shown
on the graph edges; Supplementary Fig.~\ref{fig-simplification-with-edges}
shows the graphs with these inheritance intervals included.
Graph nodes are coloured by the number of parents and shaded
according to the proportion of their span over which they are coalescent;
see the text for more details.
}
\end{figure}

The ARG in Fig.~\ref{fig-simplification}A is the output of a
backwards-time Wright-Fisher simulation for a sample of two diploid
individuals (population size $N=10$), and follows a similar process
to the methods described by~\cite{nelson2020accounting}.
As we proceed backwards in time, generation by generation, the
extant lineages chose parents randomly.
With a certain probability recombination occurs, and the ancestral
material of a lineage is split between the two parental
genomes. Local coalescence occurs
when lineages with overlapping ancestral material choose the same
parent genome.
Note that in this simulation we do not explicitly
model recombination \emph{events} via an ARG node, but simply record
the \emph{outcome} of a recombination via outbound edges to
the parent's two genomes.
Thus, a recombinant node may also correspond to a coalescence
(e.g.~node \noderef{g} in Fig.~\ref{fig-simplification}).
The distinction of
using a single node to represent
a recombination event (e.g.~Fig~\ref{fig-ancestry-resolution}),
or two to represent the parent genomes is usually not important
(either is possible in the gARG encoding)
and the most convenient approach will vary by application.
Note also that polytomies are a natural feature of such
a Wright-Fisher model
(e.g.~node \noderef{k} in Fig.~\ref{fig-simplification}).

The graph visualisations in Fig.~\ref{fig-simplification} have
three novel features which require some explanation.
Firstly, edge weights (the thickness of the lines joining
nodes) correspond to the length of the inheritance intervals
they are annotated with. This allows us to distinguish
edges that persist across many local trees from those that are
less influential (contrast the edge
$(\noderef{g}, \noderef{h})$
with $(\noderef{g}, \noderef{i})$
in Fig.~\ref{fig-simplification}A).
% FIXME this needs some work
Secondly, node colours denote the number of parents that they
have in the graph, allowing us to easily see roots (those
with zero parents), recombinants (those with two parents)
and more complex situations arising from simplification (see below).
Thirdly, the shading intensity of a node denotes the ``coalescent span'', the
fraction of the node's span (the length of genome in which it
is reachable from the samples in the local trees)
over which it is coalescent (has more than one child). Nodes which
are never locally unary therefore have a coalescent span of 100\%,
whereas nodes in which ancestral material never coalesces have a
coalescent span of 0\%.
% JK: Let's not get into discussions of identifiability or inferability
% here, we're just trying to show the things that exist in the true history.
% (such nodes will be extremely difficult to

Returning to the main topic of this section,
Fig.~\ref{fig-simplification}A is the direct output of a Wright-Fisher
simulation in which we retain all nodes involved in recombination
or common ancestry events. This is the true history, and contains
a very high level of detail, some of which may be considered
redundant (or, from another perspective, unobservable).
In Fig.~\ref{fig-simplification}A the local trees (right)
contain many unary nodes, fewer as  we successively
simplify (Fig.~\ref{fig-simplification}B,C),
until we reach Fig.~\ref{fig-simplification}D, where are none.

The first level of simplification that we can perform is based only
on the graph topology.
An example of graph topology that we may consider redundant
(or non-identifiable) is a
``diamond''~\citep{rasmussen2014genome}
in which the two parent nodes of a recombination immediately
join again into a common ancestor (e.g.~\noderef{j}, \noderef{l}, \noderef{m}
and \noderef{n} in Fig.~\ref{fig-simplification}A).
Unless we are specifically
interested in the recombination event or these ancestral genomes,
the diamond can be replaced by a single edge without loss of
information.
More generally, any subgraph that is singly-connected in both the leafward and
rootward direction (a ``super-diamond'') can be replaced by one edge.
This definition includes the case
of a node that has one inbound and one outbound edge, such as
nodes \noderef{f} and \noderef{h}.
Fig.~\ref{fig-simplification}B shows the result of this type of
graph topology simplification.

Simplifying away diamonds will remove many unary nodes from the
local trees, but there can still be nodes that are unary in all
of the local trees. In particular, a node can represent a recombinant
with multiple parents in the graph but only a single child (e.g.\ node \noderef{n}
in Fig.~\ref{fig-simplification}B), or can represent a common ancestor with
multiple children in the graph but in which no coalescence takes place
in the local trees
(node \noderef{r} in Fig.~\ref{fig-simplification}B).
The distinction between the ``common ancestry'' of two or more genomes
in an ancestral genome and the ``coalescence'' which may or may
not occur in the local trees is
important~\citep{hudson1983testing,kelleher2016efficient}.
Consider \noderef{e} in Fig.~\ref{fig-simplification}A,
for example. We can see from the graph that it is a common
ancestor of samples \noderef{a} and \noderef{b}, but
it does not correspond to any coalescence in the
local trees to the left of position $44$, and is therefore
unary in these three trees.
Such nodes are not singly connected in the graph, but are nevertheless unary in
all of the local trees.
The operation to remove them
therefore requires knowledge not just of the graph topology but also of the
ancestral material associated with the edges.
As we see in Fig.~\ref{fig-simplification}C,
removal of recombinant nodes can produce graph nodes with
more than two parents (e.g.~node \noderef{e}); and likewise, removal of
common ancestor but non-coalescent nodes can produce graph nodes with
more than two children (e.g.~node \noderef{s}). These represent the
merged
\emph{effects} of multiple evolutionary events in a single node (genome), and the
ARG no longer contains the intermediate genomes representing those events.

The remaining nodes are MRCAs of some subset of the samples
at \emph{some} positions along the genome. We still have
some unary nodes in the local trees, but these nodes will
correspond to a coalescence in at least one other
local tree. For example, node  \noderef{k} is unary in the fourth tree
of Fig.~\ref{fig-simplification}C, but is either binary
or ternary in all other local trees (recall this is a Wright-Fisher
simulation). The final level of simplification is to alter the edge annotations
such that, although no nodes are removed from the graph, all
unary nodes disappear from the local trees (Fig.~\ref{fig-simplification}D).
Note that although this last stage produces simpler local trees, by
removing information about the exact paths taken by lineages through
the graph, we lose potentially useful information about shared edges
between trees.
The \texttt{msprime} simulator, and the version of Hudson's algorithm described
by~\citet{kelleher2016efficient}, produces ARGs
that are fully simplified (i.e., contain no locally unary nodes).
It is not difficult, however, to update
these methods to record information about the passage of ancestral
material through genomes under a range of conditions.

An important consequence of simplifying ARGs to remove
unary nodes in local trees is that we lose some information
about recombination
events. This is related to the amount of \emph{precision} about
recombination events that we store and
can hope to infer from sampled genomes, which is the topic of the next
section.

\section{Precision of recombination information}
\label{sec-precision}
% The ARGs in Fig.~\ref{fig-simplification} represent different
% levels of detail about the same ancestral history. They represent
% the same set of recombination and common ancestor events,
As illustrated in Fig.~\ref{fig-simplification}, successive levels
of ARG simplification reduce the amount of information about the
history of the sample that is stored. Some of the information lost,
e.g.\ ``diamond'' removal (Fig.~\ref{fig-simplification}A),
seems like a reasonable tradeoff for a simpler structure.
The consequences of other simplifications, however, are
more subtle and relate directly to what can be known about
recombination events and the levels of precision that
we should seek to infer about them.

The ARGs in Fig.~\ref{fig-simplification} contain different
numbers of local trees ($6$, $5$, $5$ and $4$ respectively for A through
D). When we move from A to B the local trees
for the intervals $[44,61)$ and $[61,87)$ are merged because
the only differences between them are their paths through
nodes \noderef{l} and \noderef{m}. These nodes that participated
in the diamond are removed from the ARG, and we have lost
all information about the corresponding recombination at
position 61. Other nodes (e.g.\ \noderef{o} and \noderef{p})
have also been removed but these represent the \emph{parents}
of recombinants. The recombinant nodes themselves
(e.g. \noderef{n}) are still present, and represent precise
information about the time, genomic location and
lineages involved in the recombination event.

Fig.~\ref{fig-simplification}C has the same number of local trees
as Fig.~\ref{fig-simplification}B, but has less precise information
about recombination. Continuing the previous example, node
\noderef{n} has been removed from the graph because it was unary
in all of the local trees; its outbound edges to \noderef{s}
and \noderef{q} have effectively been ``pushed down''
to \noderef{e} (which is retained because it is the coalescent
parent of \noderef{a} and \noderef{b} over the interval
$[44, 100)$). We
have therefore lost precision about
the \emph{timing} of this recombination event, and know only
that it must have occurred between the times of node \noderef{e}
and \noderef{q}.

Fig.~\ref{fig-simplification}D removes all unary nodes from the
local trees, and further reduces the precision of
recombination information. Node \noderef{e} has not been
removed from the graph because it is coalescent in the
final tree, but we no longer know that the recombination
event at position 30 was ancestral to it, or have
any indication of its timings. Furthermore,
trees for $[44, 87)$ and $[87, 100)$ were only distinguishable
by the passage of the former tree through nodes \noderef{e}
and \noderef{q}, and so the recombination on node \noderef{g}
at position 87 has been lost entirely.

\section{Example inferred ARGs}
\label{sec-example-inferred-args}

\begin{figure} \begin{center}
\includegraphics[width=\textwidth]{illustrations/inference.pdf} \end{center}
\caption{\label{fig-inferred-args} Inference of sample-resolved ARGs for 11
\textit{Drosophila melanogaster} DNA sequences over a 2.4kb
region of the ADH locus~\citep{kreitman1983nucleotide}.
Results for four different methods based on
% FIXME: this is the wrong place to be summarising. Name the methods
% here and summarise in the text
(A) parsimony, (B) sampling the SMC$^\prime$, (C) copying from
inferred ancestral haplotypes, and (D) correlated local tree estimation.
Edge colours are based on the time of the edge's child node
(lighter: older; darker: younger).
X and Y positions of graph nodes are arbitrary;
line width and node colour are as described in Fig.~\ref{fig-simplification}.
Graphics on the bottom row show the genome positions, relative to the start of the ADH gene,
for each graph edge from the corresponding ARG. Edge intervals are drawn as horizontal lines,
stacked in time order (edges with youngest children at the bottom);
vertical dashed lines indicate breakpoints between local trees.
}
\end{figure}


The scalability gains made by recent ARG inference methods have been, in part, due to inferring
lower levels of precision about recombination. Indeed, a common statement in the literature is
that modern tools such as \tsinfer~\citep{kelleher2019inferring} and \relate~\citep{speidel2019method}
construct not an ARG but ``only'' a sequence of local
trees \citep[e.g.][]{hejase2020summary, brandt2021evaluation, ignatieva2021kwarg}. While this statement
is correct inasmuch as neither method attempts to infer the explicit recombination events that cause
adjacent trees to differ, it is certainly not the case that they infer independent local trees.
In fact, both methods take advantage of genome-wide mutation information to construct genealogies,
and as a result nodes and edges persist across multiple local trees.
Their results can therefore be thought of as an inheritance graph, and represented in the gARG format.

To illustrate the varying levels of information that can be captured in a gARG,
Fig.~\ref{fig-inferred-args} presents graphical representations of genealogies output by two tools that
\emph{do} explicitly infer recombination events, namely \kwarg~\citep{ignatieva2021kwarg} and
\argweaver~\citep{rasmussen2014genome},
and two which do not (\tsinfer\ and \relate).
All inferences are based on the
same underlying dataset from \citet{kreitman1983nucleotide}, a standard benchmark in the classical
ARG literature, for which the minimum number of recombination breakpoints in the absence of recurrent
mutation is 7~\citep{song2003parsimonious}. This dataset comprises 43 biallelic SNPs spanning 2.4Kb of the
\emph{D.~melanogaster} ADH locus on chromosome 2L. Where required for inference purposes we
assume a mutation rate of
$5.49\times10^{-9}$ per site per generation
and a recombination rate of
$8.4\times10^{-9}$ per site per generation
\citep{adrion2020community,lauterbur2022expanding},
together with
a constant effective population size of 1,000,000.
To focus on the ARG topology rather than estimates of node times, the Y position of each node
is arbitrary, taken from the ranked order of nodes output by each software method (see the ``Data Availability''
section for details of inference software and conversion methods).

Note that both \kwarg\ and \argweaver\ produce many ARGs
(those shown in Fig.~\ref{fig-inferred-args}A,B are arbitrarily selected examples).
This stems from the fact that \kwarg\ searches the space of plausible ARGs,
outputting minimal ones using heuristics, and \argweaver\ samples
from the posterior distribution over
ARGs given the data and a fixed model (a discretised version of the SMC$^\prime$ \citep{marjoram2006fast},
an approximation of the full coalescent with recombination).
In contrast, \tsinfer\ and \relate\ (Fig.~\ref{fig-inferred-args}C,D) are
deterministic methods, aiming to find a single ``best guess'' ARG.
The ability of a gARG to encode the effects of recombination, rather
than having to precisely specify each event, is an important contributor to this aim,
as most recombination events cannot be uniquely identified from the data.
Indeed, there is considerable variation in the number of recombinations inferred by
different methods, with e.g.~\argweaver\ (Fig.~\ref{fig-inferred-args}B) suggesting
far more than are required under minimal parsimony assumptions (Fig.~\ref{fig-inferred-args}A).

% Here we describe recombination features
A rough feel for the amount of recombination in each ARG is given by the distribution
of number of parents per node, as highlighted by the node colour scheme.
In Fig.~\ref{fig-inferred-args}A,B, each recombination event is tagged by
a node with exactly 2 parents and one child. Assuming that the breakpoint for each event
% TODO "infinite breakpoints" is goign to confuse people. What are we
% clarifying here? Citation necessary if we keep.
occurs at a different location (the ``infinite breakpoints'' model), then the
number of breakpoints should exactly equal the number of 2-parent (brown) nodes in the plot.
In contrast, Figure Fig.~\ref{fig-inferred-args}C,D have ARG nodes with multiple
parents and multiple children. These indicate deliberate imprecision, where one
or more recombinations have been ``pushed down'' onto a more recent, identifiable node.
Several of these nodes have more than two parents (in red), representing
multiple recombinations inferred to have occurred in an unresolvable order.
Nevertheless, the number of breakpoints in these two ARGs is smaller than the
number of multiple-parent ARG nodes, showing that several multiple-parent nodes
must share breakpoint positions. The sharing of breakpoint locations
between these nodes indicates that in \tsinfer\ and \relate\ ARGs it may be
difficult to condense each transition between trees into a set of simple SPR moves.
Overall, Fig.~\ref{fig-inferred-args} shows that \tsinfer\ and \relate\ ARGs contain a level
of detail about recombination that lies somewhere between a sequence of unrelated local
trees on one extreme and an ARG with precisely specified recombination events on the other.

% Here we move on to coalescence
As for inferred coalescences, the shading (``coalescent span'')
reveals that many non-recombinant (green) nodes are
locally unary (see section \ref{sec-locally-unary-edges}). In other words,
in some regions of the genome these nodes are present in the ancestry without
corresponding to coalescence of ancestral material. As argued previously, this can provide useful
information about shared ancestry. Note however, that such unary segments are not inferred
in the \relate\ ARG: other than the samples it has entirely solid nodes.
Another clear difference involves coalescent nodes with more than two children (polytomies);
in Appendix \ref{sec-cell-lineages-and-args} we argue that this reflects
uncertainty in the order of coalescent events, in an equivalent
manner to the imprecision associated with recombination nodes having more
than two parents. Only \tsinfer\ creates such polytomies, the clearest of which
involves the nodes \noderef{Fr-F}, \noderef{Wa-F}, and \noderef{Af-F}. These
happen to have identical sequences, but because \kwarg, \argweaver, and \relate\ require
bifurcating trees, they are forced to pick an arbitrary order of branching
(hence Fig.~\ref{fig-inferred-args}A,B disagrees with Fig.~\ref{fig-inferred-args}D
in this order).
More generally, the number of nodes in Fig.~\ref{fig-inferred-args}C
that have more than two children hints at considerable uncertainty in
the order of branching elsewhere in the ARG.

%% possible TODO - mention something about multiple local roots in
% tsinfer and Relate versus the other two.

%The example of successive simplification of a simulated ARG
%in Fig.~\ref{fig-simplification} illustrates the point
%that is is possible to \emph{store} arbitrary levels of precision
%about recombination in a gARG.
%It is also possible to \emph{infer} various levels of precision about
%recombination.
%To illustrate this, and to demonstrate the structural
%heterogeneity of the ARGs inferred  by current methods,
%Fig.~\ref{fig-inferred-args} shows the results of ARG inference
% To illustrate these points and to emphasise the heterogeneity
% of the ARGs inferred by current methods, we inferred ARGs for the
%for the classical \citet{kreitman1983nucleotide} benchmark dataset
%using  \kwarg~\citep{ignatieva2021kwarg},
%\argweaver~\citep{rasmussen2014genome,hubisz2020inference},
%\tsinfer~\citep{kelleher2019inferring},
%and \relate~\citep{speidel2019method}.
% While there is some consistency among the inferred ARGs (such as the samples
% FR-F, WA-F and Af-F being grouped into the same clade), there
% are also considerable differences.
%The minimum number
%of recombination breakpoints required in the absence of recurrent mutation
%is 7 for this dataset~\citep{song2003parsimonious},
%and the number of inferred breakpoints
%under the input mutation and recombination rates
%varies from 2 (\relate) to 17 (\argweaver).
% TODO this needs a bit of rewriting with the rest of the paper in mind
% kwarg and argweaver are inferring eARGs, but we need to be careful
% not to confuse people.
%The ARGs inferred by the different methods also have major differences
%in how recombination information is represented.
%Essentially,
%\kwarg\ and \argweaver\ infer eARGs that contain
%specific recombination \emph{events} for each breakpoint.
%On the other hand, \tsinfer\ and
%\relate\ do not infer events but rather
%infer gARGs with by differing levels of precision about recombination.

% TODO add additional explanation of the bottom row, if enough isn't written below
% https://github.com/tskit-dev/what-is-an-arg-paper/issues/386
The bottom row of Fig~\ref{fig-inferred-args} shows the extent along
the genome to which graph edges are shared between multiple trees.
This illustrates that both \tsinfer\ and (to a lesser extent) \relate\ have edges
that span multiple tree boundaries, indicating that they are not inferring
a series of \emph{unrelated} local trees.
%(i.e., with either unlabelled internal
%nodes or differently labelled nodes in each tree).
For example, both infer that \noderef{Af-f}, \noderef{Fr-f}, and \noderef{Wa-f}
share a common ancestor along
the entire sequence. However, in comparison to \kwarg\ and \argweaver\ neither
method results in extensive node sharing in the
oldest time periods. This primarily reflects the fact that they do not encode topology
above the local MRCAs, also indicated by multiple roots in the ARG
(nodes with zero parents, in blue), compared to the
single ARG root in the \kwarg\ and \argweaver\ genealogies. In terms of inference,
\tsinfer\ and \relate\ show a pragmatic representation: we do not expect
genetic variation to be very informative about topological relationships
between nodes that that are older than the local MRCAs.

\section{Implementation and efficiency}
\label{sec-efficiency}
The gARG encoding discussed defined here
leads to highly efficient storage and processing of ARG data,
and has already been in use for several years.
The succinct tree sequence data structure
(usually known as a ``tree sequence'' for brevity)
is a practical gARG implementation focused on efficiency.
It was originally developed as part of the \texttt{msprime}
simulator~\citep{kelleher2016efficient} and has subsequently been
extended and applied to forward-time
simulations~\citep{kelleher2018efficient,haller2018tree},
inference from data~\citep{kelleher2019inferring,wohns2022unified},
and calculation of population genetics statistics~\citep{ralph2020efficiently}.
The succinct tree sequence encoding extends the basic definition
of a gARG provided here by stipulating a
simple tabular representation of nodes and edges,
and also defining a concise representation of
sequence variation using the ``site'' and  ``mutation'' tables.
The key property of the succinct tree sequence encoding
that makes it an efficient substrate for defining analysis
algorithms is that it allows us to sequentially
recover the local trees along the genome very efficiently,
and in a way that allows us to reason about the \emph{differences}
between those trees~\citep{kelleher2016efficient,ralph2020efficiently}.

The \texttt{tskit} library is a liberally
licensed open source toolkit that provides a comprehensive suite
of tools for working with gARGs (encoded as a succinct tree sequence).
Based on core functionality written
in C, it provides interfaces in C, Python and Rust.
Tskit is mature software, widely used in population genetics, and
has been incorporated into several downstream
applications~\citep[e.g.,][]{haller2019slim,speidel2019method,
adrion2020community,
terasaki2021geonomics,
baumdicker2021efficient,
fan2022genealogical,
guo2022recombination,
korfmann2022weak,
mahmoudi2022bayesian,
petr2022slendr,
rasmussen2022espalier,
zhang2023biobank,
nowbandegani2023extremely,
ignatieva2023distribution,
fan2023likelihood}.
The technical details of \texttt{tskit}, and how it provides an
efficient and portable platform for ARG-based analysis, are beyond
the scope of this manuscript.
In the interest of avoiding confusion, however, we list a
few minor details in which the formal details of gARGs
provided here differ from their practical implementation in
\texttt{tskit}.
Firstly, ``edges'' in tree sequence terminology would be perhaps better be
described as ``edge-intervals'', as each describes a single contiguous
interval of genome inheritance between a pair of nodes.
This denormalisation of the gARG data model is for efficiency purposes.
Secondly, $-1$ is used to denote the presence of
roots in an oriented tree, rather than $0$ as used here for notational
simplicity.

% \cite{shipilina2023origin} discuss the idea of a ``haplotype block''
% (equivalent to the ``bricked tree sequence'' of
% \cite{nowbandegani2023extremely},
% % TODO look this up. I expect it's basically the same??
% and the block-based ARG data structure of
% \citep{palamara2016argon}),
% here we consider the unique sets of
% samples that coalesce at a node in the ARG over a particular
% genome interval, and the fundamental limitations they place
% on ARG inference.
% [FIXME find somewhere natural for this. The last clause is too vague - what
% are the implications?]
% Alternative gARG encodings split transmitted intervals and associate each with
% a new node, resulting in a single genome being represented by a group of
% multiple nodes (or ``blocks'' \citep{palamara2016argon}), with implications for

%%%% Some old text about the coalescent we might still want to plunder
% % If we want to use the coalescent, then really the assumptions
% % need to make sense.
% % n << Ne is a silly assumption in today's datasets
% A core assumption of the coalescent is that the sample size $n$
% is much less than the effective population size, $N_e$.
% Several human datasets now consist of hundreds of thousands of
% genomes~\citep{bycroft2018genome,karczewski2020mutational,tanjo2021practical},
% and so sample size is substantially \emph{larger} than $N_e$
% (often assumed to be $10^4$ in humans).
% Agricultural datasets are even more extreme.
% For example,
% the US dairy cattle database alone currently comprises more than 6 million
% animals with SNP array
% genotypes\footnote{\url{https://queries.uscdcb.com/Genotype/counts.html}},
% while the effective population size in modern dairy cattle breeds is
% less than 100 and decreasing~\citep{MacLeod2013,Makanjuola2020}.
% An extreme sign of these breeding practices is that there are only two ancestral
% Y-chromosome lineages present in today's US Holstein dairy breed~\citep{Yue2015}.
% Simlarly, the 1000 bull genomes project~\citep{hayes20191000}
% comprises close to 7000 genomes, which are part of multi-generation pedigrees
% with millions of animals and extensive SNP array genotype and phenotype
% data \citep[e.g.][]{Cesarani2022}.
% In another example, genome and SNP array data for 440,610 individuals within
% 7 multi-generation pedigrees~\citep{whalen2018,Johnsson2021,Ros-Freixedes2020}
% were combined to infer recombination in pigs~\citep{RosFreixedes2022}.
% Effective population size in modern pig breeds is also less than 100 due to
% intense selection and directed reproduction \citep{Hall2016,Porcnic2016}.
% Another core assumption of the coalescent model is that the genome (or
% at least the region under study) is short enough that the number of extant
% lineages remains much smaller than $N_e$ at all times. Whole
% genome sequences have been available for model organisms
% for over a decade now, % True? Citation?
% and indeed complete chromosome-level assemblies are possible
% in humans~\citep{miga2020telomere}.
% Projects are under way to obtain high-quality assemblies
% for all eukaryotic species in Britain and Ireland~\citep{darwin2022sequence}
% and ultimately worldwide~\citep{lewin2022earth}.

\section{Discussion}
\label{sec-discussion}
Recent breakthroughs have finally made large-scale ARG inference
feasible in practice, leading to a surge of interest
in inference methods, their evaluation, and their application to biological questions.
The prospect of ARGs being used routinely within population
and statistical genetics is tantalising,
but in reality there is substantial work to be done to
enable this.
A necessary first step is a degree of terminological clarity.
As discussed in Appendix~\ref{sec-arg-history}, the term
``ancestral recombination graph" has several
subtly different interpretations, depending on context.
The trend to decouple ARGs from their original definition
within the context of stochastic
processes and instead use the term as a more general representation of any
recombinant genetic ancestry seems useful, and we have
tried to clarify and systematise it here. Thus
we can think of an ARG as any structure that encodes the
reticulate genetic ancestry of a sample of colinear sequences under
the influence of recombination. The ``genome'' ARG (gARG) encoding
made explicit here is one way we can concretely
define such recombinant ancestry, which we have shown is both
flexible and efficient.
The flexibility of the gARG encoding contrasts with the classical
``event'' ARG (eARG) encoding, which is more limited in what can be described.
Importantly, gARGs do not require fully precise estimates of
ancestral recombination events,
and allow us to directly express important forms of temporal uncertainty.

Fully decoupling the general concept of an ARG from the coalescent
with recombination stochastic process (henceforth, ``coalescent'')
is an important step.
While the coalescent has proven to be a useful and
robust
model~\citep{wakeley2012gene,bhaskar2014distortion,nelson2020accounting},
many modern datasets have properties that grossly
violate its assumptions.
One key assumption is that
sample size $n$ is much less than the effective population size, $N_e$.
Several human datasets now consist of hundreds of thousands of
genomes~\citep{turnbull2018hundred, bycroft2018genome,
karczewski2020mutational,tanjo2021practical,
halldorsson2022sequences},
and so sample size is an order of magnitude \emph{larger} than the
usually assumed $N_e$ values.
Agricultural datasets are an even more extreme departure from this
assumption, with hundreds of thousands of samples embedded in
multi-generational pedigrees~\citep{hayes20191000,Ros-Freixedes2020}
and effective population sizes of 100 and even
less~\citep{MacLeod2013,Makanjuola2020,Hall2016,Porcnic2016}.
A model assuming a single $N_e$ would be a
drastic over-simplification of course, but
even if sufficiently complex demographic models~\citep{gower2022demes}
encompassing hundreds of populations, explosive growth rates and myriad
interconnections of migration, were somehow estimated and provided as input,
ARGs sampled from the coalescent cannot capture the complexities
of family structure in these
datasets~\citep[e.g.][]{turnbull2018hundred,Ros-Freixedes2020}.
Another core assumption of the coalescent model is that the genome
(or at least the region under study) is short enough that the number of extant
lineages remains much smaller than $N_e$ at all times.
High-quality whole genome assemblies are now available
for many species % Can we say something more concrete here?
and projects are under way to obtain
them for tens of thousands more~\citep{darwin2022sequence,lewin2022earth},
and so we can expect inferred ARGs to routinely span whole chromosomes.

Recent large-scale methods have simplified the inference problem by
making a single, deterministic best-guess at ARG
inference~\citep{kelleher2019inferring,speidel2019method,zhan2023towards}.
Even under strict parsimony conditions and for small sample sizes, the
% Citation? This is something people have figured out, right?
number of plausible ARGs compatible with a given dataset is vast.
Thus, although it is clearly an oversimplification to arbitrarily
choose \emph{one} best guess, it is not clear that sampling more
when sample sizes are large will achieve much.
At the scale of millions of samples,
we could only ever explore the tiniest corner of the incomprehensibly
large space of likely ARGs.
Therefore, it is important to systematically
describe and utilise uncertainty about ARG inference, and to
incorporate uncertainty encountered during inference into the returned ARG.
One approach, enabled by the gARG encoding described here, is to allow
nodes to have (rootward) in-degree greater than two (polytomies
representing uncertainty over the ordering of coalescence events) or
out-degree greater than two (representing uncertainty over the ordering
of multiple recombination events). Development of other methods to capture, for example,
uncertainty about node ages and recombination breakpoint positions, is an important
aspect of future work. Fully utilising such uncertainty in downstream
applications is also vital, of course.

The timing, positions, and even the number of recombination events is generally
not possible to infer precisely from genome sequencing data. Under
coalescent-based models, the proportion of recombination events that change the
ARG topology grows very slowly with sample size \citep{hein2004gene}, and of those
events only a small proportion are actually detectable from the data, assuming
human-like mutation and recombination rates \citep{myers2002detection,hayman2023recoverability}.
Even when a recombination event \emph{is} detectable, its timing and breakpoint
position can only be inferred approximately, depending on how much information
can be elucidated from mutations in the surrounding genomic region.
% For general
% ARGs, for instance those representing pedigrees, or genealogies of organisms with
% low mutation rates and complex patterns of recombination, such inference can be
% even more challenging.
The fact that the eARG encoding \emph{requires}
precise information about recombination is therefore a fundamental limitation.
% % Do downstream applications actually make use of such full ARGs?
Besides the inherent limitations that exist on inferring fully
precise ARGs from data,
we should also consider the value that such precise estimates provide
for downstream applications.
Many applications work by examining local trees independently.
For example, the \relate\ selection test~\citep{speidel2019method}
obtains $p$-values by computing clade size probabilities conditional
on the timing of coalescence events in a given local tree.
In their method
for estimating dispersal rates and the locations of genetic
ancestors,
\cite{osmond2021estimating} downsample trees along the genome
so that they can be regarded as approximately independent.
Similarly, \cite{fan2023likelihood} compute the likelihood
of an ARG under a particular demographic model as the product
over a sample of widely-separated local trees, assumed to be independent.
The SIA method for detecting selection~\citep{hejase2022deep}
encodes local trees as a set of lineage counts at discrete
time intervals, and uses these as feature for a
type of machine learning algorithm
that takes ``temporal'' correlations into account.
Thus, while SIA takes advantage of information about local tree correlation,
it is in quite an indirect way, and
clearly much of the detail about recombination events in an ARG is lost.
The \texttt{tsdate} algorithm (and related naive estimator
of ancestral location) uses much more between-tree
information~\citep{wohns2022unified}, explicitly using the gARG
encoding to reason about ancestral nodes.
The main application for fully precise ARGs thus far has been
to compute a likelihood under the
coalescent~\citep[e.g.][]{kuhner2000maximum,mahmoudi2022bayesian,
guo2022recombination},
which currently requires the details of all recombination
events to be known.

The advantages of a model-agnostic representation that naturally
incorporates uncertainty about the ordering of events in an ARG
are well-illustrated by~\cite{zhan2023towards}, who
inferred ARGs using millions of SARS-CoV-2 sequences from the
GISAID database~\citep{shu2017gisaid}.
In contrast to typical human sequencing datasets, the SARS-CoV-2 data is
sampled continuously through time, sometimes with tens of thousands of sequences collected per day, with relatively little genetic diversity to
distinguish them. The reconstructed ARGs thus contain polytomies (representing
both the uncertainty around coalescence times and the presence of true
multiple mergers), non-leaf sample nodes (sequences with descendants
also present in the dataset) and unary nodes (samples that have
one direct descendant).
Recombination is an important factor in the evolution of
SARS-CoV-2~\citep{vaninsberghe2021recombinant,jackson2021generation,ignatieva2022ongoing},
% Tried to jazz this up a bit, was quite dry
and the inferred ARGs contain an unprecedented level of detail about
the combined processes of viral mutation and recombination.
Because parental sequences
are generally never sampled themselves, and often
a recombinant strain is the product of multiple recombination events,
uncertainty around this is captured by recording the ancestry
of each part of the recombinant sequence without arbitrarily assigning
times or orderings for these events.

This view of ARGs,
decoupled from generative models and
without the hard requirement
of complete precision on all historical events, may clarify inference goals and improve
methods for evaluation.
In most cases,
ARG inference is evaluated by simulating data from a known ground truth ARG,
and comparing this to the inferred version via pairwise comparison of
local trees along the genome, for example
using tree distance
metrics~\citep[e.g.][]{robinson1981comparison,kendall2016mapping},
as described by \citet{kuhner2015assessing}.
% While this provides valuable insights into the method's performance,
% it is not clear how well these tree distance metrics reflect
% performance on real data.
In comparing tree-by-tree along the genome, the effects of recombination
are incorporated in a rather indirect manner through the correlations
between the local trees, instead of directly taking into account
the persistence of nodes and edges across multiple trees.
The performance of tree distance metrics varies by
application~\citep{kuhner2015assessing}, and the correct approach
to handling subtleties such as polytomies
is an open question~\citep{kelleher2019inferring,zhang2023biobank}.
% Is this true? These guys claim RF takes linear time:
% https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-020-07011-0
Tree distance metrics often have at least $O(n^2)$ time complexity
and therefore cannot be
applied to the very large sample sizes currently of interest.
A recent trend has been to move away from such
tree distance-based approaches and to examine more
properties of the inferred ARGs, such as
distributions of pairwise MRCA times~\citep{brandt2021evaluation},
waiting distances between local trees~\citep{deng2021distribution},
and the genomic span of an edge or clade of
samples~\citep{ignatieva2023distribution}.
In each case, simulation studies demonstrated
substantial differences between these quantities in simulated and reconstructed ARGs,
that were not captured using tree-by-tree comparisons.
Evaluations to-date have almost all been based
on ground truth data from highly idealised simulations,
with sample sizes limited to at most a few thousand (typically much fewer).
Beyond the effects of very simplistic error models~\cite[e.g.][]{kelleher2019inferring},
the effects of the richness of real data
at biobank-scale on ARG inference are almost entirely unknown.
The development of ARG evaluation metrics that take into account more of the
global topology and can be applied to large ARGs would be a
valuable and timely addition to the field.

Interest in ARG inference methods and downstream applications is
burgeoning, with exciting developments arriving at ever-increasing pace.
Without agreement on basic terminology and some standardisation
on data formats, however, the ARG revolution may falter.
For ARG-based methods to achieve mainstream status, we require
a rich supporting software ecosystem.
Ideally, this would comprise a wide range of different
inference methods specialised to different organisms, types
and scales of data and
% I'm thinking about things like Espalier specifically wanting
% to characterise the recombs, vs Relate mainly wanting to
% get good local trees
targetting particular inference goals, sharing a common ARG interchange format.
The output of these diverse inference methods could then be
processed by numerous downstream applications,
enabling users to freely compare the outputs of different
inference methods on their data, and the result of different
analyses on these inferences.
Earlier efforts to standardise ARG interchange shared this vision,
but did not succeed~\citep{cardona2008extended,mcgill2013graphml}.
Without a well-defined and efficient shared format
for ARG data interchange,
users will suffer from problems with converting data from one program's
output to another, an unfortunate hallmark of population genetics
software for many years~\citep{excoffier2006computer}.
Current methods tend to tightly couple downstream analysis
of the inferred ARG with the inference
itself within the same software package,
which is ultimately not compatible with the widespread use
of ARGs for routine data analysis, and a healthy and diverse software ecosystem.
The gARG encoding described here is a significant generalisation
of classical concepts, capable of describing even the bewildering complexity
of contemporary datasets and capturing important forms of temporal uncertainty.
The \texttt{tskit} library is a high-quality open-source gARG implementation,
with proven efficiency and
scalability~\citep[e.g.][]{anderson2022genes,zhan2023towards},
that is already in widespread use.
Adopting it as a community standard,
and utilising its rich suite of operations,
may accelerate progress and help to
establish ARG methods within mainstream genetics.

\section*{Data Availability}

The public GitHub repository at \url{https://github.com/tskit-dev/what-is-an-arg-paper} can be
used to reproduce all figures and tables in this paper. In particular this includes
the ARG used in Fig.~\ref{fig-ancestry-resolution}; the simulation code and functions
used to generate Fig.~\ref{fig-simplification}; and for Fig.~\ref{fig-inferred-args},
the software versions, parameter settings, and (where necessary) functions to convert
software outputs to the \texttt{tskit} gARG format.

\section*{Acknowledgements}
We are grateful to Nick Barton, Gideon Bradburd, Alex Lewanski and Andrew Vaughan
for helpful discussions and comments on the manuscript.

% Ordered alphabetically by surname
Gregor Gorjanc acknowledges support from the BBSRC ISP grant to The Roslin Institute
(BBS/E/D/30002275, BBS/E/RL/230001A, and BBS/E/RL/230001C).
% Anastasia Ignatieva acknowledges support from TODO
% TODO Jerome: add EPSRC and NIH HG011395-0 grants.
Jerome Kelleher acknowledges support from the Robertson Foundation.
Jere Koskela acknowledges support from EPSRC research grant EP/V049208/1.
% Anthony Wilder Wohns acknowledges support from TODO

\bibliographystyle{plainnat}
\bibliography{paper}

\setcounter{secnumdepth}{2} % Print out appendix section numbers

% TODO revisit number here
\section*{Appendix}
\appendix

\setcounter{table}{0}
\setcounter{figure}{0}
\renewcommand{\thetable}{A\arabic{table}}
\renewcommand{\thefigure}{A\arabic{figure}}

\section{Ancestral graphs: a brief history}
\label{sec-arg-history}
The coalescent~\citep{kingman1982coalescent,kingman1982genealogy,
hudson1983testing, tajima1983evolutionary} models the ancestry of a sample of
genomes under an idealised population model, and provides the theoretical
underpinning for much of contemporary population genetics.
It is a stochastic process, where each random realisation
is a genealogical tree describing the genetic ancestry of the sample.
Numerous extensions to the model have been
proposed~\citep{hudson1990gene,hein2004gene,wakely2008coalescent},
incorporating many evolutionary processes.
\citet{hudson1983properties}
first incorporated recombination into the coalescent process,
providing several fundamental analytical results
and describing the basic simulation algorithm, still in
widespread use~\citep{hudson2002generating,kelleher2016efficient,
baumdicker2021efficient}.
In the 1990s, Griffiths and colleagues revisited the
coalescent with recombination from a different perspective,
formulating it as a stochastic process where each realisation
is encoded as a graph~\citep{griffiths1991two,ethier1990two,
griffiths1996ancestral,griffiths1997ancestral}.
They referred to both the stochastic process and
its random realisations as the Ancestral Recombination Graph (ARG).
Although mathematically equivalent, it is
important to note that the Griffiths and Hudson formulations of
the coalescent with recombination are not identical;
in particular, a direct implementation of the ARG process
as originally described requires exponential time to simulate
(see Appendix~\ref{sec-big-and-little-arg} for details).
However, ARGs provided a way
to reason about and infer recombinant ancestry as a single object,
in a way that not possible within Hudson's framework, which emphasised
instead the collection of local trees along the genome
resulting from recombination.

Subsequent work on ARGs proceeded in broadly three main directions:
(1) exploring the mathematical properties of the coalescent with recombination and
related stochastic processes;
(2) inferring evolutionary parameters under
(approximations to) this model, either with or without explicitly reconstructing the
genealogy of the sample;
and (3) treating the ARG as a discrete graph, ignoring the
generating stochastic process, and studying its properties from a computational and
algorithmic perspective.

% Mathematical treatment of the CwR and ARGs (and ARG-like stochastic processes)
An extensive body of work has been developed from
studying the coalescent with recombination
% Can we add a couple of the most well known CwR examples here
and other related
graph-valued stochastic processes from a mathematical perspective.
In particular, the Ancestral Selection Graph
(ASG)~\citep{krone1997ancestral,neuhauser1997genealogy}
uses a similar approach to model natural selection instead of recombination.
Unlike the ARG process, the ASG imposes a hard distinction between the stochastic process,
which constructs a random ARG-like graph, and an observable realisation,
which is a single tree sampled from the graph in a non-uniform way to encode
desired patterns of natural selection.
Constructions of ASG-like stochastic processes encoding various
forms of selection, often in parallel with recombination or other genetic forces,
are an area of considerable and ongoing theoretical interest~\citep[e.g.][]{
neuhauser1999ancestral,
donnelly1999genealogical,
fearnhead2001perfect,
fearnhead2003ancestral,
etheridge2009coalescent,
gonzalezcasanova2018duality,
koskela2019robust}.
% Could mention the Ancestral Gene Transfer graph here too, within
% something like "Similarly the Ancestral Gene Transfer Graph [cite]
% and [other ancestral graphs, if they exist?] model genealogical
% processes in bacteria as a graph.

% Inference of parameters and explicit ARG reconstruction
Early work on inference under the coalescent with recombination
focused on the problem of
inferring the parameters of the
stochastic process, where the ancestry was regarded as a
latent parameter to be averaged out
\citep[e.g.][]{griffiths1996ancestral,kuhner2000maximum, nielsen2000estimation,
fearnhead2001estimating}.
These methods met with limited success
because the state space of ARGs is overwhelmingly large, and
lacks a simple geometry or neighbourhood structure for inference or
sampling methods to  exploit.
Several breakthroughs in this direction were achieved through
formulating simplified but more tractable approximations to the full
model~\citep{mcvean2005approximating,marjoram2006fast,li2011inference,
paul2011accurate,schiffels2014inferring}.
The related problem of \emph{sampling} genealogies compatible with a given
dataset under the coalescent with recombination also proved notoriously difficult
computationally; progress in explicitly inferring genealogies at scale
has similarly been achieved through resorting to principled
approximations~\citep{rasmussen2014genome,mahmoudi2022bayesian},
or moving away from the coalescent with recombination altogether and seeking
to infer a single plausible ARG~\citep[e.g.][]{
minichiello2006mapping,kelleher2019inferring,speidel2019method}.

% Optimisation problems to do with ARGs and other phylogenetic networks
There has also been substantial interest in formulating and answering
fundamental questions about properties
of the ARG as a discrete graph structure, focusing on the ARG topology without considering
either branch lengths or indeed the generating process.
The first prominent problem was calculating (lower bounds on) the minimum number of
recombinations required to reconstruct a valid genealogy for a given
sample~\citep{myers2003bounds}, and constructing the corresponding
minimal (parsimonious)
ARGs~\citep{song2003parsimonious,song2005efficient,lyngso2005minimum}.
These problems are NP-hard in general~\citep{wang2001perfect}, and progress has
been achieved through studying various constrained special cases of ARGs~\citep[e.g.][]{gusfield2004optimal} and
other more general types of phylogenetic networks~\citep{huson2010phylogenetic}. The
focus has been on algorithmic and combinatorial results~\citep{gusfield2014recombinatorics}
that are often not of
direct relevance to the inference problems described above.

%It is important to note that parsimonious ARGs
%have quite different properties from realisations of the
%ARG \emph{process} as modelled by Hudson, Griffiths, and colleagues.
%Firstly, branch lengths are not typically estimated,
%% why do we need the following two lines
%and node times are required in order to compute a likelihood under the
%coalescent with recombination (see section XXX).
%Secondly, even if branch lengths were estimated,
%the realisations would have a very small likelihood since
%the coalescent with recombination is often highly \emph{un}parsimonious
%in terms of recombination events.

The goal of this historical overview is to illustrate that the meaning of the term ``ARG" now strongly
depends on the context in which it is used, and can mean both the
stochastic process that generates genealogies in the presence of
recombination~\citep[e.g.][]{nordborg2000linkage,birkner2013ancestral,
wilton2015smc,griffiths2016coalescent},
as well as, more commonly, the concrete realisation of ancestry from a
process~\citep[e.g.][]{gusfield2014recombinatorics,mathieson2020ancestry,brandt2021evaluation}.

\section{The Big and Little ARG}
\label{sec-big-and-little-arg}
Here we review two important stochastic processes that construct ARGs:
the ``Big" ARG process of \cite{griffiths1997ancestral}, and the ``Little" ARG process of
 \cite{hudson1983properties}. The Big ARG process is mathematically simpler
 but is computationally intractable due to generating a vast number of ancestors
 which contribute no genetic material to the initial sample.
The Little ARG process avoids non-genetic ancestors at the cost of more complex
dynamics and state space. We also demonstrate that evaluating the sampling probability
of either process---a key quantity in many statistical approaches---requires that the
gARG (or eARG) data structure be interpreted in a model-specific way.

A generic state of the Little ARG process consists of a finite collection of lineages $L$,
each of which is a list of disjoint ancestry segments $(\ell, r, a)$, where
$[\ell, r)$ is a half-closed genomic interval and $a$ is an integer
tracking the number of samples to which the lineage is ancestral over that interval.
We also usually track the node associated with each segment, but
that is not important for our purposes here so we omit it to lighten notation.
The initial condition for a sample of $n$ genomes of length $m$ consists of $n$ lineages
of the form $\{(0, m, 1)\}$. The process traverses a series of common ancestor and
recombination events backwards in time.
Recombination events happen at rate $\rho \nu / (m - 1)$,
where $\rho \geq 0$ is a per-genome recombination rate and
 \[
 \nu = \sum_{x \in L}\left( \max_{(\ell, r, a) \in x}r
     - \min_{(\ell, r, a) \in x}\ell - 1 \right)
 \]
 is the number of available ``links" surrounded by ancestral material.
 At a recombination event we choose one of these links uniformly and break it,
 replacing the original lineage in $L$ with two new lineages containing the ancestral material
 to the left and right of the break point, respectively.

Common ancestor events occur at rate $\binom{|L|}{2}$.
In a common ancestor event, two uniformly sampled lineages have their segments
merged into a single ancestor lineage, which is added to $L$.
If the lineages have overlapping intervals of ancestry,
say, $(\ell, r, a_1)$ and $(\ell, r, a_2)$, a
\emph{coalescence} occurs. The result is a segment
$(\ell, r, a_1 + a_2)$, and if $a_1 + a_2 < n$ it is included in the
ancestor lineage. Otherwise, if $a_1 + a_2 = n$, we have found
the most recent common ancestor of all samples in the interval $[\ell, r)$
and do not need to simulate its history any further.
Non-overlapping intervals from the two lineages are included
 in the ancestor lineage without changes. Eventually,
we find resultant lineages in which all segments have fully coalesced,
and so the number of extant lineages gradually falls to zero.

In the Griffiths formulation (the Big ARG process), each edge in the graph corresponds to an extant
lineage and nodes are events in the process. The $n$ initial leaf nodes are
sampling events. Common ancestor events occur at rate $\binom{|L|}{2}$.
When a common ancestor event happens, two uniformly chosen lineages
merge into a common ancestor lineage.
Recombination events happen at rate $|L| \rho$. Here, we choose a lineage (i.e.\ edge) uniformly,
and a breakpoint $0 < x < m$ uniformly on its genome. We terminate the edge at a
node, record the breakpoint, and start two new edges from this node. The process
then continues until there is only one lineage left (the Grand Most Recent
Common Ancestor, GMRCA), which is guaranteed to
happen in finite time because of the quadratic rate of coalescing vs.\ linear rate of branching.

The state-space of the Big ARG process is much simpler than that of the Little ARG process,
which greatly facilitates mathematical reasoning. This simplicity comes at a
substantial cost, however, if we wish to use it as a practical means of
simulating recombinant ancestries.
The number of events in the Big ARG all the way back to the GMRCA
is $O(e^\rho)$~\citep{griffiths1997ancestral}, whereas the number
of events required to simulate the Little ARG is
$O(\rho^2)$~\citep{hein2004gene,baumdicker2021efficient}.
This disparity arises because the majority of the events in the Big ARG are
recombination events which occur outside of ancestral material,
and these do not have any bearing on the ancestry of the initial sample.
Because we don't keep track of the distribution of ancestral material during the process,
we generate a vastly larger graph.

\begin{figure}
\centering
% FIXME this is a quick nasty hack to make the figure a bit smaller and
% prevent flushing all the other figures to the end of the document.
\scalebox{0.54}{
\begin{tabular}{cc}
\begin{tikzpicture}
	\node [anchor=north west] at (-3.5,9.3) {\LARGE \textbf{A}};
	\draw (-0.4, -0.2) -- (0.4, -0.2) -- (0.4, -0.3) -- (-0.4, -0.3) -- (-0.4, -0.2);
	\draw (-0.1, -0.1) -- (-0.1, -0.4);
	\node [label=below:{\small $v$}] at (-0.1, -0.2) {};
	\draw (3.6, -0.2) -- (4.4, -0.2) -- (4.4, -0.3) -- (3.6, -0.3) -- (3.6, -0.2);
	\draw (5.6, -0.2) -- (6.4, -0.2) -- (6.4, -0.3) -- (5.6, -0.3) -- (5.6, -0.2);

	\draw (4,0) -- (4, 1.2) -- (6, 1.2) -- (6,0);
	\draw (4.6, 1) -- (5.4, 1) -- (5.4, 0.9) -- (4.6, 0.9) -- (4.6, 1);
	\draw (5.1, 1.1) -- (5.1, 0.8);
	\node [label=below:{\small $w$}] at (5.1, 1) {};

	\draw (0, 0) -- (0, 1.7) -- (-1,1.7) -- (1,1.7);
	\draw (-1.4, 1.5) -- (-1.1, 1.5) -- (-1.1, 1.4) -- (-1.4, 1.4) -- (-1.4, 1.5);
	\draw (-1.1, 1.45) -- (-0.6, 1.45);
	\draw (0.6, 1.45) -- (0.9, 1.45);
	\draw (0.9, 1.5) -- (1.4, 1.5) -- (1.4, 1.4) -- (0.9, 1.4) -- (0.9, 1.5);
	\draw (1.1, 1.6) -- (1.1, 1.3);
	\node [label=below:{\small $w$}] at (1.1, 1.5) {};

	\draw (5, 1.2) -- (5, 2.4) -- (4,2.4) -- (6,2.4);
	\draw (3.6, 2.2) -- (4.1, 2.2) -- (4.1, 2.1) -- (3.6, 2.1) -- (3.6, 2.2);
	\draw (4.1, 2.15) -- (4.4, 2.15);
	\draw (5.6, 2.15) -- (6.1, 2.15);
	\draw (6.1, 2.2) -- (6.4, 2.2) -- (6.4, 2.1) -- (6.1, 2.1) -- (6.1, 2.2);

	\draw (1, 1.7) -- (1, 3.1) -- (0,3.1) -- (2,3.1);
	\draw (-0.4, 2.85) -- (0.1, 2.85);
	\draw (0.1, 2.9) -- (0.4, 2.9) -- (0.4, 2.8) -- (0.1, 2.8) -- (0.1, 2.9);
	\draw (1.6, 2.85) -- (1.9, 2.85);
	\draw (1.9, 2.9) -- (2.1, 2.9) -- (2.1, 2.8) -- (1.9, 2.8) -- (1.9, 2.9);
	\draw (2.1, 2.85) -- (2.4, 2.85);

	\draw (-1, 1.7) -- (-1, 4.5) -- (0,4.5) -- (0,3.1);
	\node [scale=0.2,label=above left:{\small \noderef{a}}] at (-0.5,4.5) {a};
	\draw (-0.9, 4.3) -- (-0.6, 4.3) -- (-0.6, 4.2) -- (-0.9, 4.2) -- (-0.9, 4.3);
	\draw (-0.6, 4.25) -- (-0.4, 4.25);
	\draw (-0.4, 4.3) -- (-0.1, 4.3) -- (-0.1, 4.2) -- (-0.4, 4.2) -- (-0.4, 4.3);
	\draw (-0.5, 4.4) -- (-0.5, 4.1);
	\node [label=below:{\small $x$}] at (-0.5, 4.3) {};

	\draw (4,2.4) -- (4,5.4) -- (2,5.4) -- (2,3.1);
	\node [scale=0.2,label=above left:{\small \noderef{b}}] at (3,5.4) {b};
	\draw (2.6, 5.2) -- (2.9, 5.2) -- (2.9, 5.1) -- (2.6, 5.1) -- (2.6, 5.2);
	\draw (2.9, 5.15) -- (3.4, 5.15);

	\draw (-0.5, 4.5) -- (-0.5, 6) -- (-1.5,6) -- (0.5,6);
	\draw (-1.9, 5.75) -- (-1.4, 5.75);
	\draw (-1.4, 5.8) -- (-1.1, 5.8) -- (-1.1, 5.7) -- (-1.4, 5.7) -- (-1.4, 5.8);
	\draw (0.1, 5.8) -- (0.4, 5.8) -- (0.4, 5.7) -- (0.1, 5.7) -- (0.1, 5.8);
	\draw (0.4, 5.75) -- (0.9, 5.75);

	\draw (0.5, 6) -- (0.5, 7.2) -- (3,7.2) -- (3,5.4);
	\node [scale=0.2,label=above:{\small \noderef{c}}] at (1.75,7.2) {c};
	\draw (1.35, 6.95) -- (2.15, 6.95);

	\draw (-1.5, 6) -- (-1.5, 8);
	\draw (6, 2.4) -- (6, 8);

	% Edge annotations above each event
	\node [label=left:{\small$\{(0,m,1)\}$}] at (0.2,0.6) {};
	\node [label=left:{\small$\{(0,m,1)\}$}] at (4.2,0.4) {};
	\node [label=right:{\small$\{(0,m,1)\}$}] at (5.8,0.4) {};
	\node [label=left:{\small$\{(0,m,2)\}$}] at (5.2,1.6) {};
	\node [label=left:{\small$\{(0,v,1)\}$}] at (-0.8,2.3) {};
	\node [label=right:{\small$\{(v,m,1)\}$}] at (0.8,2.1) {};
	\node [label=right:{\small$\{(0,w,2)\}$}] at (3.8,3.9) {};
	\node [label=left:{\small$\{(w,m,2)\}$}] at (6.2,5) {};
	\node [label=right:{\small$\{(w,m,1)\}$}] at (-0.2,3.8) {};
	\node [label=right:{\small$\{(v,w,1)\}$}] at (1.8,4.1) {};
	\node [label=left:{\small$\{(0,v,1), (w,m,1)\}$}] at (-0.3,5.2) {};
	\node [label=right:{\small$\{(0,v,2)\}$}] at (2.8,6.4) {};
	\node [label=left:{\small$\{(w,m,1)\}$}] at (-1.3,7) {};
	\node [label=right:{\small$\{(0,v,1)\}$}] at (0.3,6.4) {};

	% Dashed lines for start and end times
	\draw[dashed] (-2, 0) -- (11, 0);
	\node [label=left:{$t = 0$}] at (-2,0) {};
	\draw[dashed] (-2, 8) -- (11, 8);
	\node [label=left:{$t = T$}] at (-2,8) {};

	% Numbers of extant ancestors and links, from top to bottom
	\node[label=right:{CA \; RE}] at (7.5, 8.2) {};
	\node[label=right:{$\binom{2}{2}$ \; $\frac{2 m - 2 w - 2}{m - 1} \rho$}] at (7.5, 7.6) {};
	\node[label=right:{$\binom{4}{2}$ \; $\frac{2 m + 2 v - 2 w - 4}{m - 1} \rho$}] at (7.5, 6.6) {};
	\node[label=right:{$\binom{3}{2}$ \; $\frac{2 m + v - w - 3}{m - 1} \rho$}] at (7.5, 5.7) {};
	\node[label=right:{$\binom{4}{2}$ \; $\frac{2 m + w - v - 4}{m - 1} \rho$}] at (7.5, 4.95) {};
	\node[label=right:{$\binom{5}{2}$ \; $\frac{2 m - 5}{m - 1} \rho$}] at (7.5, 3.8) {};
	\node[label=right:{$\binom{4}{2}$ \; $\frac{2 m - 4}{m -1} \rho$}] at (7.5, 2.75) {};
	\node[label=right:{$\binom{3}{2}$ \; $\frac{2 m - 3}{m - 1} \rho$}] at (7.5, 2.05) {};
	\node[label=right:{$\binom{2}{2}$ \; $2 \rho$}] at (7.5, 1.45) {};
	\node[label=right:{$\binom{3}{2}$ \; $3 \rho$}] at (7.5, 0.6) {};

	% Gray dashed lines to visually separate holding times
	\draw[color=gray, dashed] (7.5, 1.2) -- (11, 1.2);
	\draw[color=gray, dashed] (7.5, 1.7) -- (11, 1.7);
	\draw[color=gray, dashed] (7.5, 2.4) -- (11, 2.4);
	\draw[color=gray, dashed] (7.5, 3.1) -- (11, 3.1);
	\draw[color=gray, dashed] (7.5, 4.5) -- (11, 4.5);
	\draw[color=gray, dashed] (7.5, 5.4) -- (11, 5.4);
	\draw[color=gray, dashed] (7.5, 6) -- (11, 6);
	\draw[color=gray, dashed] (7.5, 7.2) -- (11, 7.2);
\end{tikzpicture}
&
\begin{tikzpicture}
	\node [anchor=north west] at (-3.5,9.3) {\LARGE \textbf{B}};
	\draw (-0.4, -0.2) -- (0.4, -0.2) -- (0.4, -0.3) -- (-0.4, -0.3) -- (-0.4, -0.2);
	\draw (-0.1, -0.1) -- (-0.1, -0.4);
	\node [label=below:{\small $v$}] at (-0.1, -0.2) {};
	\draw (3.6, -0.2) -- (4.4, -0.2) -- (4.4, -0.3) -- (3.6, -0.3) -- (3.6, -0.2);
	\draw (5.6, -0.2) -- (6.4, -0.2) -- (6.4, -0.3) -- (5.6, -0.3) -- (5.6, -0.2);

	\draw (4,0) -- (4, 1.2) -- (6, 1.2) -- (6,0);
	\draw (4.6, 1) -- (5.4, 1) -- (5.4, 0.9) -- (4.6, 0.9) -- (4.6, 1);
	\draw (5.1, 1.1) -- (5.1, 0.8);
	\node [label=below:{\small $w$}] at (5.1, 1) {};

	\draw (0, 0) -- (0, 1.7) -- (-1,1.7) -- (1,1.7);
	\draw (-1.4, 1.5) -- (-1.1, 1.5) -- (-1.1, 1.4) -- (-1.4, 1.4) -- (-1.4, 1.5);
	\draw (-1.1, 1.45) -- (-0.6, 1.45);
	\draw (0.6, 1.45) -- (0.9, 1.45);
	\draw (0.9, 1.5) -- (1.4, 1.5) -- (1.4, 1.4) -- (0.9, 1.4) -- (0.9, 1.5);
	\draw (1.1, 1.6) -- (1.1, 1.3);
	\node [label=below:{\small $w$}] at (1.1, 1.5) {};

	\draw (5, 1.2) -- (5, 2.4) -- (4,2.4) -- (6,2.4);
	\draw (3.6, 2.2) -- (4.1, 2.2) -- (4.1, 2.1) -- (3.6, 2.1) -- (3.6, 2.2);
	\draw (4.1, 2.15) -- (4.4, 2.15);
	\draw (5.6, 2.15) -- (6.1, 2.15);
	\draw (6.1, 2.2) -- (6.4, 2.2) -- (6.4, 2.1) -- (6.1, 2.1) -- (6.1, 2.2);
	\draw [color=red](5.8, 2.3) -- (5.8, 2.0);
	\node [label={[red]below:{\small $y$}}] at (5.8, 2.1) {};

	\draw (1, 1.7) -- (1, 3.1) -- (0,3.1) -- (2,3.1);
	\draw (-0.4, 2.85) -- (0.1, 2.85);
	\draw (0.1, 2.9) -- (0.4, 2.9) -- (0.4, 2.8) -- (0.1, 2.8) -- (0.1, 2.9);
	\draw (1.6, 2.85) -- (1.9, 2.85);
	\draw (1.9, 2.9) -- (2.1, 2.9) -- (2.1, 2.8) -- (1.9, 2.8) -- (1.9, 2.9);
	\draw (2.1, 2.85) -- (2.4, 2.85);

	\draw (-1, 1.7) -- (-1, 4.5) -- (0,4.5) -- (0,3.1);
	\draw (-0.9, 4.3) -- (-0.6, 4.3) -- (-0.6, 4.2) -- (-0.9, 4.2) -- (-0.9, 4.3);
	\draw (-0.6, 4.25) -- (-0.4, 4.25);
	\draw (-0.4, 4.3) -- (-0.1, 4.3) -- (-0.1, 4.2) -- (-0.4, 4.2) -- (-0.4, 4.3);
	\draw (-0.5, 4.4) -- (-0.5, 4.1);
	\node [label=below:{\small $x$}] at (-0.5, 4.3) {};

	\draw (6, 2.4) -- (6, 3.8) -- (7, 3.8);
	\draw [color=red](6, 3.8) -- (5, 3.8);
	\draw (4.6, 3.55) -- (5.4, 3.55);
	\draw (6.6, 3.55) -- (7.1, 3.55);
	\draw (7.1, 3.6) -- (7.4, 3.6) -- (7.4, 3.5) -- (7.1, 3.5) -- (7.1, 3.6);

	\draw (4,2.4) -- (4,5.4) -- (2,5.4) -- (2,3.1);
	\draw (2.6, 5.2) -- (2.9, 5.2) -- (2.9, 5.1) -- (2.6, 5.1) -- (2.6, 5.2);
	\draw (2.9, 5.15) -- (3.4, 5.15);

	\draw (-0.5, 4.5) -- (-0.5, 6) -- (-1.5,6) -- (0.5,6);
	\draw (-1.9, 5.75) -- (-1.4, 5.75);
	\draw (-1.4, 5.8) -- (-1.1, 5.8) -- (-1.1, 5.7) -- (-1.4, 5.7) -- (-1.4, 5.8);
	\draw (0.1, 5.8) -- (0.4, 5.8) -- (0.4, 5.7) -- (0.1, 5.7) -- (0.1, 5.8);
	\draw (0.4, 5.75) -- (0.9, 5.75);

	\draw [color=red](5, 3.8) -- (5, 6.6) -- (4, 6.6);
	\draw (4,6.6) -- (3,6.6) -- (3, 5.4);
	\draw (3.6, 6.4) -- (3.9, 6.4) -- (3.9, 6.3) -- (3.6, 6.3) -- (3.6, 6.4);
	\draw (3.9, 6.35) -- (4.4, 6.35);

	\draw (0.5, 6) -- (0.5, 7.2) -- (4,7.2) -- (4,6.6);
	\draw (1.85, 6.95) -- (2.65, 6.95);

	\draw (-1.5, 6) -- (-1.5, 8);
	\draw [color=red](2.25, 7.2) -- (2.25, 8);
	\draw (7, 3.8) -- (7, 8);

	% Dashed lines for start and end times
	\draw[dashed] (-2, 0) -- (9.1, 0);
	\node [label=left:{$t = 0$}] at (-2,0) {};
	\draw[dashed] (-2, 8) -- (9.1, 8);
	\node [label=left:{$t = T$}] at (-2,8) {};

	% Numbers of extant ancestors and links, from top to bottom
	\node[label=right:{CA \; RE}] at (7.5, 8.2) {};
	\node[label=right:{$\binom{3}{2}$ \; $3 \rho$}] at (7.5, 7.6) {};
	\node[label=right:{$\binom{4}{2}$ \; $4 \rho$}] at (7.5, 6.9) {};
	\node[label=right:{$\binom{5}{2}$ \; $5 \rho$}] at (7.5, 6.3) {};
	\node[label=right:{$\binom{4}{2}$ \; $4 \rho$}] at (7.5, 5.7) {};
	\node[label=right:{$\binom{5}{2}$ \; $5 \rho$}] at (7.5, 4.95) {};
	\node[label=right:{$\binom{6}{2}$ \; $6 \rho$}] at (7.5, 4.15) {};
	\node[label=right:{$\binom{5}{2}$ \; $5 \rho$}] at (7.5, 3.45) {};
	\node[label=right:{$\binom{4}{2}$ \; $4 \rho$}] at (7.5, 2.75) {};
	\node[label=right:{$\binom{3}{2}$ \; $3 \rho$}] at (7.5, 2.05) {};
	\node[label=right:{$\binom{2}{2}$ \; $2 \rho$}] at (7.5, 1.45) {};
	\node[label=right:{$\binom{3}{2}$ \; $3 \rho$}] at (7.5, 0.6) {};

	% Gray dashed lines to visually separate holding times
	\draw[color=gray, dashed] (7.5, 1.2) -- (9.1, 1.2);
	\draw[color=gray, dashed] (7.5, 1.7) -- (9.1, 1.7);
	\draw[color=gray, dashed] (7.5, 2.4) -- (9.1, 2.4);
	\draw[color=gray, dashed] (7.5, 3.1) -- (9.1, 3.1);
	\draw[color=gray, dashed] (7.5, 3.8) -- (9.1, 3.8);
	\draw[color=gray, dashed] (7.5, 4.5) -- (9.1, 4.5);
	\draw[color=gray, dashed] (7.5, 5.4) -- (9.1, 5.4);
	\draw[color=gray, dashed] (7.5, 6) -- (9.1, 6);
	\draw[color=gray, dashed] (7.5, 6.6) -- (9.1, 6.6);
	\draw[color=gray, dashed] (7.5, 7.2) -- (9.1, 7.2);
\end{tikzpicture}
\end{tabular}
}
\caption{(A)
A realisation of the graph traversed by Hudson's algorithm started from a
sample of three chromosomes with $m$ discrete sites each at time $t = 0$, and
propagated until time $T$. The MRCA on the genetic interval $[v, w)$ is reached
at event \noderef{b}, while that on $[0, v)$ is reached at event \noderef{c}.
The non-ancestral segment $[v, w)$ above
\noderef{a} contributes to the rate of effective recombinations because it
is trapped between ancestral segments. The two columns titled CA and RE
are the respective rates of mergers and recombinations when
the recombination rate is $\rho$.
(B) A corresponding realisation of a Big ARG, which augments Hudson's algorithm
by tracking nonancestral lineages. The result is a simpler state space and
dynamics, at the cost of extra nodes and edges, highlighted in red, which do
not affect the local tree at any site.
Recombination positions are labelled alphabetically in time, and their ordering
along the genome is $y < v < x < w$, of which the first only appears in panel B.
There are two separate recombination events at link $w$.
}
\label{hudson_vs_bigARG}
\end{figure}

Figure \ref{hudson_vs_bigARG} illustrates the more complex state space
of the Little ARG process, as well as the extra events which occur in the Big ARG process.
Moreover, it depicts the rates of common ancestors and recombination events in each
interval of time of the realisations.
In order to evaluate these rates, and hence the sampling probability
\cite[see e.g.][Equation (3)]{mahmoudi2022bayesian},
it is necessary to know the number of lineages and number of extant links
available for recombination in each time interval.
Some representations may not provide this information.
For example, in the gARG encoding depicted in Figure \ref{fig-ancestry-resolution}C
it is clear that a recombination takes place between nodes \noderef{b} and
\noderef{d} as well as \noderef{e}, but the exact time of the event is ambiguous,
and thus so is the number of lineages during the time interval. In fact, this
information cannot be recovered from the gARG encoding used in Figure \ref{fig-ancestry-resolution}C,
and alternative conventions must be introduced to resolve such ambiguities.
For the likelihood-based inference algorithms for the coalescent with recombination,
it is sufficient to create \emph{two} gARG nodes at the time of the recombination event:
see the appendix of \cite{baumdicker2021efficient} for details of evaluating
coalescent with recombination likelihoods using this convention.
This is also the interpretation depicted in
Figure \ref{hudson_vs_bigARG}, but it means that the two edges above node \noderef{b}
in Figure \ref{fig-ancestry-resolution} should correspond to only one lineage,
along which all $m-1$ links are available for recombination.
The lineage then splits into two at the time of nodes \noderef{d} and \noderef{e}.
Nodes \noderef{k}, \noderef{l}, and \noderef{m} in Figure \ref{fig-ancestry-resolution}
demonstrate that the same issue can affect the number of links available for recombination:
without an external convention, the exact time at which the trapped ancestral material on
node \noderef{k} ceases to be available for an effective recombination in the Little ARG process.


% Full quote:
% This process simplifies mathematics on the account that the notion of an
% ancestor will have a less restrictive meaning than usual:
% An ``ancestral'' sequence in the birth and death process
% need not have any genetic material in common with a
% sequence descended from it.

\section{Survey of ARG inference methods}
\label{sec-survey-arg-infer}

The problem of reconstructing ARGs for samples of recombining sequences has
been of interest since the ARG was first defined. Early methods focused on
finding \emph{parsimonious} ARGs, i.e.\ those with a minimal number of
recombination events~\citep{hein1990reconstructing}. Two main approaches
emerged: ``backwards-in-time''~\citep{lyngso2005minimum} and
``along-the-genome'' \citep{song2003parsimonious, song2005constructing}.
Backwards-in-time approaches
start with a data matrix and reduce it to an empty matrix through row
and column operations corresponding to coalescence, mutation, and recombination
events, which construct an ARG from the bottom up~\citep{song2005efficient,
wu2008association,thao2019hybrid,ignatieva2021kwarg}.
Along-the-genome approaches
begin from an initial local tree at a single focal site.
Moving the focal site along the
genome changes the local tree via a subtree prune and regraft
operation whenever a recombination is encountered~\citep{hein1993heuristic,
wu2011new, mirzaei2017rent}.
\citet{rasmussen2022espalier} focus on parsimonious fusion of local
trees into an ARG, while the method described by
\citet{camara2016inference} is based on topological data analysis.
% The "most" is understood here, surely
Reconstructing a parsimonious ARG for a given data set is NP-hard
\citep{wang2001perfect}, so parsimony-based methods resort to heuristics and
are limited to analysing at most hundreds of sequences. Hence, a number of
methods aim to balance computational efficiency with reconstruction of
``reasonable'', rather than parsimonious ARGs
% distribution under a population genetics model
\citep{minichiello2006mapping,
parida2008estimating, kelleher2019inferring,  speidel2019method,
schaefer2021ancestral, zhang2023biobank}.

% AI: just to note, these papers do not all agree in their definition of an
% ARG. I guess this is one of the points of the present paper, but should we
% mention this fact? Should we also mention that most of these infer just the
% topology, but some also the times?

An alternative approach is to treat the ARG as a latent parameter to be
averaged out by Monte Carlo methods, based either on importance sampling
\citep{griffiths1996ancestral, fearnhead2001estimating, jenkins2011inference}
or MCMC \citep{kuhner2000maximum, kuhner2006lamarc, nielsen2000estimation, wang2008bayesian,
wang2009population, fallon2013acg, vaughan2017inferring, mahmoudi2022bayesian}.
These methods operate on representations
of the ``Little ARG'' (see Appendix \ref{sec-big-and-little-arg}), and are computationally expensive, being
applicable to at most hundreds of samples consisting of tens or hundreds of
kilobases with human-like parameters.
State-of-the-art methods rely on cheaper,
approximate models \citep{didelot2010inference, heine2018bridging,
hubisz2020mapping,hubisz2020inference, medina2020speeding}. The most scalable
method, \texttt{ARGWeaver} \citep{rasmussen2014genome}, can be applied to
dozens of mammal-like genomes \citep{hubisz2020inference}.

Methods to sample ARGs generate a ``cloud'' of estimates, and
\cite{kuhner2017consensus} provide an approach to generate a
set of consensus breakpoints and local trees from
such a cloud.
The approach is based on examining the recombination breakpoints
in all of the input ARGS, and including those that are
in at least $k$ of the input ARGs (with some additional
filtering criteria) in the output.
Within the resulting intervals, a consensus
local tree is then generated using standard phylogenetic methods.

% Not sure we want this content now? We're not really talking about
% evaluation of liklihoods any more.
% A central quantity
% in all of these sampling methods is the conditional sampling probability $p(G |
% D) \propto p(D | G) p(G)$ of an ARG $G$ given an observed realization of
% genetic diversity $D$ at its sampled leaves, where $p(D | G)$ is the likelihood
% of the data $D$ given $G$, and $p(G)$ is a Bayesian prior distribution or a
% frequentist regularizer for the ARG $G$.

% The likelihood $p(D | G)$ is effectively always the distribution of a Poisson
% process on the ancestral material along the edges of $G$ \citep[Eq.\
% (2)]{mahmoudi2022bayesian}. Hence it is typically straightforward to evaluate
% in principle, but choosing the right data structure can still have a dramatic
% effect on the efficiency of evaluation \citep{mahmoudi2022bayesian}. Especially
% in the Bayesian case, $p(G)$ is typically specified as the sampling
% distribution of a stochastic process, such as the coalescent with
% recombination. Two contemporary examples are \citet{mahmoudi2022bayesian} and
% \citet{guo2022recombination}. Evaluating the distribution of the coalescent with
% recombination (or related models) requires knowledge of the number of extant
% lineages and number of links available for recombination (i.e.\ ones at which a
% recombination would split ancestral material) at each time \citep[Eq.\
% (3)]{mahmoudi2022bayesian}. These require a data structure from which shared
% edges on different trees are easy to identify, and which encodes recombination
% events and times explicitly, e.g.\ using nodes.

\section{Cell lineages and ARGs}
\label{sec-cell-lineages-and-args}
As we have argued, an important benefit of the gARG representation is that it
can concatenate multiple events by encoding the outcome of their effects
on a single node. In the case of recombination events, this manifests itself as
a single node with three or more parents (e.g.\ Fig.~\ref{fig-simplification}C, node \noderef{e}).
Here we make the argument that the same principle underlies ARGs containing
coalescence points that involve three or more children. These ``polytomies'' are generated not only
by Wright-Fisher dynamics such as those in Fig.~\ref{fig-simplification}C (see node \noderef{k}), but also
by life histories that involve ``burst'' reproduction events, which are often modelled by a lambda
coalescent process [AND OTHERS]\citep{wakely2008coalescent}.

\begin{figure}
\begin{center}
    \includegraphics[width=0.8\textwidth]{illustrations/cell-lines}
\end{center}
\caption{\label{fig-cell-lines}
Cellular inheritance of a single chromosome in a diploid population.
Individuals (blue) contain diploid cells (white circles enclosing a homologous pair of chromosomes).
For clarity, only two rounds of mitotic germ-line cell division are shown per individual, and
meiosis is not illustrated in detail.
Lines show prospective inheritance paths for all chromosomes. Solid lines show all possible
retrospective ancestry paths for four chosen chromosomes (indicated by square black ``sampling events'')
sampled from 3 diploid individuals ($D_1$, $D_2$, $D_3$) in the current generation.
Ancestral recombination events and coalescence events are shown as red and blue squares respectively.
The ARG paths for the lower arm of the sampled chromosomes (green) is highlighted as a
think solid line and involves a single recombination event and four coalescence events
(highlighted as deep red and blue squares within individuals $D_5$, $D_{10}$, and $D_{13}$).
ARG lineages also show gametic genomes, contained within shaded circles.
As in Fig.~\ref{fig-arg-in-pedigree}A, inherited regions within the sampled chromosome arm are
shaded by the number of descendant samples.
}
\end{figure}

At the base of this concept is a subtle and important point about which genomes are represented by gARG nodes.
In principle, we can interpret nodes as representing genomes
at any point in the life cycle, for instance, \citet{hudson1983properties} views nodes as representing gametes,
whereas in Fig.~\ref{fig-arg-in-pedigree}A, we present them as genomes within a diploid individual.
In reality, however, recombination and replication of DNA occur at a cellular level,
and respectively correspond to the processes of meiosis and mitosis. Therefore, a comprehensive gARG would not
trace genetic inheritance between diploid individuals, but between cells during the
life cycle of these individuals. This is illustrated in Fig.~\ref{fig-cell-lines}, where we show a simplified
schematic of cellular inheritance in a diploid population over four partially overlapping generations.
In this figure, thick black lines trace an ARG that describes the ancestry of the lower arm of the
four sampled chromosomes. The ``events'' underlying the ARG are shown as red and blue squares,
and the potential ARG nodes are shown as green chromosomal regions. Note that a number of these nodes are
``pass-through'' nodes with one parent and one child, which would normally be omitted.

The unusual feature of this particular example is that three ARG lineages coalesce in one historical individual,
$D_{10}$, whose three children all happen to be ancestors of the sampled chromosomes.
We can see that the process that generates these three child lineages actually consists of two successive bifurcations:
necessitated by the fact that the only known method of reproducing DNA is by (semi-conservative) duplication.
However, if we take each node in the ARG to represents the generalised genome of an individual (rather than the specific
genome of a cell within an individual) we end up representing this as a instantaneous trifucation or polytomy.

There is biological significance to this cellular-level inheritance process. Were a mutation to occur
during the first cell division of $D_{10}$, the two gametes produced by the cells
in the left half of $D_{10}$ could share a mutation not present in the right hand gamete. In other words,
the relationship between three (or more) gametes that originate, without recombination, from the same parental
chromosomes will nevertheless be strictly bifurcating; two of the gametes have a closer relationship with the
third more distant. Of course, unless mutations occur between successive rounds of cell division, the between-cell
relationships will be impossible to infer from the data.

% As with concatenating multiple recombination events, the gARG representation allows us to concatenate within-individual
% coalescence events such that we are not obliged to represent precisely the underlying cellular process. In humans and
% other multicellular diploids, it seems most intuitive to take the nodes in the gARG to represent two haploid genomes within
% a newly fertilised diploid individual. If this individual has 3 or more children, and these children feature in the
% eventual ancestry of the samples, the gARG approach outlined in this paper means that they can be legitimately represented
% by a polytomy in the local trees.

\clearpage
\renewcommand\thefigure{S\arabic{figure}}
\setcounter{figure}{0}
\renewcommand\thetable{S\arabic{table}}
\setcounter{table}{0}

\section*{Supplementary Material}

\begin{figure}[ht]
	\begin{center}
		\includegraphics[width=0.8\textwidth]{illustrations/simplification-with-edges.pdf}
	\end{center}
	\caption{\label{fig-simplification-with-edges}
	Example ARGs Fig.~\ref{fig-simplification}A--D,
    with edges annotated with inheritance intervals.
	}
\end{figure}

\end{document}
